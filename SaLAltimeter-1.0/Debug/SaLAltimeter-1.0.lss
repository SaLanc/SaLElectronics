
SaLAltimeter-1.0.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000c20  00000000  00000000  00008000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     00000438  20000000  00000c20  00010000  2**3
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000028c  20000438  00001058  00010438  2**2
                  ALLOC
  3 .stack        00002004  200006c4  000012e4  00010438  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  00010438  2**0
                  CONTENTS, READONLY
  5 .comment      0000005b  00000000  00000000  00010460  2**0
                  CONTENTS, READONLY
  6 .debug_info   0000a4ee  00000000  00000000  000104bb  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000135c  00000000  00000000  0001a9a9  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    00002000  00000000  00000000  0001bd05  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 000001d8  00000000  00000000  0001dd05  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000190  00000000  00000000  0001dedd  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0001355d  00000000  00000000  0001e06d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   00004961  00000000  00000000  000315ca  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    0006dec9  00000000  00000000  00035f2b  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00000508  00000000  00000000  000a3df4  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <_sfixed>:
   0:	200026c8 	.word	0x200026c8
   4:	00000599 	.word	0x00000599
   8:	00000591 	.word	0x00000591
   c:	00000591 	.word	0x00000591
	...
  2c:	00000591 	.word	0x00000591
	...
  38:	00000591 	.word	0x00000591
  3c:	00000591 	.word	0x00000591
  40:	00000591 	.word	0x00000591
  44:	00000591 	.word	0x00000591
  48:	00000591 	.word	0x00000591
  4c:	00000591 	.word	0x00000591
  50:	00000591 	.word	0x00000591
  54:	00000591 	.word	0x00000591
  58:	00000591 	.word	0x00000591
  5c:	00000591 	.word	0x00000591
  60:	00000591 	.word	0x00000591
  64:	00000591 	.word	0x00000591
  68:	00000591 	.word	0x00000591
  6c:	00000591 	.word	0x00000591
  70:	00000591 	.word	0x00000591
  74:	00000591 	.word	0x00000591
  78:	00000591 	.word	0x00000591
  7c:	00000591 	.word	0x00000591
  80:	00000591 	.word	0x00000591
  84:	00000591 	.word	0x00000591
  88:	00000591 	.word	0x00000591
  8c:	00000591 	.word	0x00000591
  90:	00000591 	.word	0x00000591
	...
  9c:	00000591 	.word	0x00000591
  a0:	00000591 	.word	0x00000591
  a4:	00000591 	.word	0x00000591
  a8:	00000591 	.word	0x00000591
  ac:	00000591 	.word	0x00000591
  b0:	00000000 	.word	0x00000000

000000b4 <__do_global_dtors_aux>:
  b4:	b510      	push	{r4, lr}
  b6:	4c06      	ldr	r4, [pc, #24]	; (d0 <__do_global_dtors_aux+0x1c>)
  b8:	7823      	ldrb	r3, [r4, #0]
  ba:	2b00      	cmp	r3, #0
  bc:	d107      	bne.n	ce <__do_global_dtors_aux+0x1a>
  be:	4b05      	ldr	r3, [pc, #20]	; (d4 <__do_global_dtors_aux+0x20>)
  c0:	2b00      	cmp	r3, #0
  c2:	d002      	beq.n	ca <__do_global_dtors_aux+0x16>
  c4:	4804      	ldr	r0, [pc, #16]	; (d8 <__do_global_dtors_aux+0x24>)
  c6:	e000      	b.n	ca <__do_global_dtors_aux+0x16>
  c8:	bf00      	nop
  ca:	2301      	movs	r3, #1
  cc:	7023      	strb	r3, [r4, #0]
  ce:	bd10      	pop	{r4, pc}
  d0:	20000438 	.word	0x20000438
  d4:	00000000 	.word	0x00000000
  d8:	00000c20 	.word	0x00000c20

000000dc <frame_dummy>:
  dc:	b508      	push	{r3, lr}
  de:	4b08      	ldr	r3, [pc, #32]	; (100 <frame_dummy+0x24>)
  e0:	2b00      	cmp	r3, #0
  e2:	d003      	beq.n	ec <frame_dummy+0x10>
  e4:	4807      	ldr	r0, [pc, #28]	; (104 <frame_dummy+0x28>)
  e6:	4908      	ldr	r1, [pc, #32]	; (108 <frame_dummy+0x2c>)
  e8:	e000      	b.n	ec <frame_dummy+0x10>
  ea:	bf00      	nop
  ec:	4807      	ldr	r0, [pc, #28]	; (10c <frame_dummy+0x30>)
  ee:	6803      	ldr	r3, [r0, #0]
  f0:	2b00      	cmp	r3, #0
  f2:	d100      	bne.n	f6 <frame_dummy+0x1a>
  f4:	bd08      	pop	{r3, pc}
  f6:	4b06      	ldr	r3, [pc, #24]	; (110 <frame_dummy+0x34>)
  f8:	2b00      	cmp	r3, #0
  fa:	d0fb      	beq.n	f4 <frame_dummy+0x18>
  fc:	4798      	blx	r3
  fe:	e7f9      	b.n	f4 <frame_dummy+0x18>
 100:	00000000 	.word	0x00000000
 104:	00000c20 	.word	0x00000c20
 108:	2000043c 	.word	0x2000043c
 10c:	00000c20 	.word	0x00000c20
 110:	00000000 	.word	0x00000000

00000114 <getevents>:
    byteOut(module,ADXL345_REG_DATA_FORMAT);
    byteOut(module,_cmd);
    SaLDigitalOut(module->SS,true);
}

void getevents(struct spiModule *const module) {
 114:	b5f0      	push	{r4, r5, r6, r7, lr}
 116:	b083      	sub	sp, #12
 118:	1c04      	adds	r4, r0, #0
    SaLDigitalOut(module->SS,false);
 11a:	78c3      	ldrb	r3, [r0, #3]
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 11c:	09d9      	lsrs	r1, r3, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 11e:	2200      	movs	r2, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 120:	2900      	cmp	r1, #0
 122:	d104      	bne.n	12e <getevents+0x1a>
        return &(ports[port_index]->Group[group_index]);
 124:	095a      	lsrs	r2, r3, #5
 126:	01d2      	lsls	r2, r2, #7
 128:	491b      	ldr	r1, [pc, #108]	; (198 <getevents+0x84>)
 12a:	468c      	mov	ip, r1
 12c:	4462      	add	r2, ip

void SaLPinMode(uint8_t pin,uint8_t DIR);

static inline void SaLDigitalOut(uint8_t pin, uint8_t level) {
	volatile PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
 12e:	211f      	movs	r1, #31
 130:	400b      	ands	r3, r1
 132:	391e      	subs	r1, #30
 134:	4099      	lsls	r1, r3
	

	if (level) {
		port->OUTSET.reg = pin_mask;
		} else {
		port->OUTCLR.reg = pin_mask;
 136:	6151      	str	r1, [r2, #20]
    byteOut(module,ADXL345_REG_DATAX0 | 0x80 | 0x40);
 138:	1c20      	adds	r0, r4, #0
 13a:	21f2      	movs	r1, #242	; 0xf2
 13c:	4b17      	ldr	r3, [pc, #92]	; (19c <getevents+0x88>)
 13e:	4798      	blx	r3

    volatile uint16_t xreading = getBits(module,16);
 140:	1c20      	adds	r0, r4, #0
 142:	2110      	movs	r1, #16
 144:	4e16      	ldr	r6, [pc, #88]	; (1a0 <getevents+0x8c>)
 146:	47b0      	blx	r6
 148:	466b      	mov	r3, sp
 14a:	1d9f      	adds	r7, r3, #6
 14c:	80d8      	strh	r0, [r3, #6]
    volatile uint16_t yreading = getBits(module,16);
 14e:	1c20      	adds	r0, r4, #0
 150:	2110      	movs	r1, #16
 152:	47b0      	blx	r6
 154:	ad01      	add	r5, sp, #4
 156:	8028      	strh	r0, [r5, #0]
    volatile uint16_t zreading = getBits(module,16);
 158:	1c20      	adds	r0, r4, #0
 15a:	2110      	movs	r1, #16
 15c:	47b0      	blx	r6
 15e:	466b      	mov	r3, sp
 160:	1c9a      	adds	r2, r3, #2
 162:	8058      	strh	r0, [r3, #2]
    curaccelX = xreading;
 164:	883b      	ldrh	r3, [r7, #0]
 166:	490f      	ldr	r1, [pc, #60]	; (1a4 <getevents+0x90>)
 168:	800b      	strh	r3, [r1, #0]
    curaccelY = yreading;
 16a:	882b      	ldrh	r3, [r5, #0]
 16c:	490e      	ldr	r1, [pc, #56]	; (1a8 <getevents+0x94>)
 16e:	800b      	strh	r3, [r1, #0]
    curaccelZ = zreading;
 170:	8813      	ldrh	r3, [r2, #0]
 172:	4a0e      	ldr	r2, [pc, #56]	; (1ac <getevents+0x98>)
 174:	8013      	strh	r3, [r2, #0]
    SaLDigitalOut(module->SS,true);
 176:	78e3      	ldrb	r3, [r4, #3]
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 178:	09d9      	lsrs	r1, r3, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 17a:	2200      	movs	r2, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 17c:	2900      	cmp	r1, #0
 17e:	d104      	bne.n	18a <getevents+0x76>
        return &(ports[port_index]->Group[group_index]);
 180:	095a      	lsrs	r2, r3, #5
 182:	01d2      	lsls	r2, r2, #7
 184:	4904      	ldr	r1, [pc, #16]	; (198 <getevents+0x84>)
 186:	468c      	mov	ip, r1
 188:	4462      	add	r2, ip

void SaLPinMode(uint8_t pin,uint8_t DIR);

static inline void SaLDigitalOut(uint8_t pin, uint8_t level) {
	volatile PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
 18a:	211f      	movs	r1, #31
 18c:	400b      	ands	r3, r1
 18e:	391e      	subs	r1, #30
 190:	4099      	lsls	r1, r3
	

	if (level) {
		port->OUTSET.reg = pin_mask;
 192:	6191      	str	r1, [r2, #24]

}
 194:	b003      	add	sp, #12
 196:	bdf0      	pop	{r4, r5, r6, r7, pc}
 198:	41004400 	.word	0x41004400
 19c:	00000271 	.word	0x00000271
 1a0:	000003e5 	.word	0x000003e5
 1a4:	2000045c 	.word	0x2000045c
 1a8:	20000458 	.word	0x20000458
 1ac:	2000045a 	.word	0x2000045a

000001b0 <currentX>:
int16_t currentX() {
    return (curaccelX);
 1b0:	4b01      	ldr	r3, [pc, #4]	; (1b8 <currentX+0x8>)
 1b2:	8818      	ldrh	r0, [r3, #0]
 1b4:	b200      	sxth	r0, r0
}
 1b6:	4770      	bx	lr
 1b8:	2000045c 	.word	0x2000045c

000001bc <currentY>:
int16_t currentY() {
    return (curaccelY);
 1bc:	4b01      	ldr	r3, [pc, #4]	; (1c4 <currentY+0x8>)
 1be:	8818      	ldrh	r0, [r3, #0]
 1c0:	b200      	sxth	r0, r0
}
 1c2:	4770      	bx	lr
 1c4:	20000458 	.word	0x20000458

000001c8 <currentZ>:
int16_t currentZ() {
    return (curaccelZ);
 1c8:	4b01      	ldr	r3, [pc, #4]	; (1d0 <currentZ+0x8>)
 1ca:	8818      	ldrh	r0, [r3, #0]
 1cc:	b200      	sxth	r0, r0
 1ce:	4770      	bx	lr
 1d0:	2000045a 	.word	0x2000045a

000001d4 <read_coeff>:

	return _receive;

}

void read_coeff(struct spiModule *const module) {
 1d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 1d6:	464f      	mov	r7, r9
 1d8:	4646      	mov	r6, r8
 1da:	b4c0      	push	{r6, r7}
 1dc:	1c04      	adds	r4, r0, #0
 1de:	2500      	movs	r5, #0

	uint16_t coefficient;
	for (uint8_t coeff_num = 0; coeff_num < 6 ; ++coeff_num ) {

		uint8_t _cmd = cmdPromRd_ + ((coeff_num+1)*2);
		delay_us(300);
 1e0:	4b1e      	ldr	r3, [pc, #120]	; (25c <read_coeff+0x88>)
 1e2:	4698      	mov	r8, r3
		SaLDigitalOut(module->SS,false);
		byteOut(module,_cmd);
 1e4:	4f1e      	ldr	r7, [pc, #120]	; (260 <read_coeff+0x8c>)
		uint8_t _byte1 = getByte(module);
 1e6:	4e1f      	ldr	r6, [pc, #124]	; (264 <read_coeff+0x90>)
 1e8:	1c2b      	adds	r3, r5, #0
 1ea:	3b5e      	subs	r3, #94	; 0x5e
 1ec:	b2db      	uxtb	r3, r3
 1ee:	4699      	mov	r9, r3

	uint16_t coefficient;
	for (uint8_t coeff_num = 0; coeff_num < 6 ; ++coeff_num ) {

		uint8_t _cmd = cmdPromRd_ + ((coeff_num+1)*2);
		delay_us(300);
 1f0:	2096      	movs	r0, #150	; 0x96
 1f2:	0040      	lsls	r0, r0, #1
 1f4:	47c0      	blx	r8
		SaLDigitalOut(module->SS,false);
 1f6:	78e3      	ldrb	r3, [r4, #3]
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 1f8:	09d9      	lsrs	r1, r3, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 1fa:	2200      	movs	r2, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 1fc:	2900      	cmp	r1, #0
 1fe:	d104      	bne.n	20a <read_coeff+0x36>
        return &(ports[port_index]->Group[group_index]);
 200:	095a      	lsrs	r2, r3, #5
 202:	01d2      	lsls	r2, r2, #7
 204:	4918      	ldr	r1, [pc, #96]	; (268 <read_coeff+0x94>)
 206:	468c      	mov	ip, r1
 208:	4462      	add	r2, ip

void SaLPinMode(uint8_t pin,uint8_t DIR);

static inline void SaLDigitalOut(uint8_t pin, uint8_t level) {
	volatile PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
 20a:	211f      	movs	r1, #31
 20c:	400b      	ands	r3, r1
 20e:	391e      	subs	r1, #30
 210:	4099      	lsls	r1, r3
	

	if (level) {
		port->OUTSET.reg = pin_mask;
		} else {
		port->OUTCLR.reg = pin_mask;
 212:	6151      	str	r1, [r2, #20]
		byteOut(module,_cmd);
 214:	1c20      	adds	r0, r4, #0
 216:	4649      	mov	r1, r9
 218:	47b8      	blx	r7
		uint8_t _byte1 = getByte(module);
 21a:	1c20      	adds	r0, r4, #0
 21c:	47b0      	blx	r6
 21e:	4681      	mov	r9, r0
		uint8_t _byte2 = getByte(module);
 220:	1c20      	adds	r0, r4, #0
 222:	47b0      	blx	r6

		SaLDigitalOut(module->SS,true);
 224:	78e3      	ldrb	r3, [r4, #3]
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 226:	09d9      	lsrs	r1, r3, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 228:	2200      	movs	r2, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 22a:	2900      	cmp	r1, #0
 22c:	d104      	bne.n	238 <read_coeff+0x64>
        return &(ports[port_index]->Group[group_index]);
 22e:	095a      	lsrs	r2, r3, #5
 230:	01d2      	lsls	r2, r2, #7
 232:	490d      	ldr	r1, [pc, #52]	; (268 <read_coeff+0x94>)
 234:	468c      	mov	ip, r1
 236:	4462      	add	r2, ip

void SaLPinMode(uint8_t pin,uint8_t DIR);

static inline void SaLDigitalOut(uint8_t pin, uint8_t level) {
	volatile PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
 238:	211f      	movs	r1, #31
 23a:	400b      	ands	r3, r1
 23c:	391e      	subs	r1, #30
 23e:	4099      	lsls	r1, r3
	

	if (level) {
		port->OUTSET.reg = pin_mask;
 240:	6191      	str	r1, [r2, #24]

		coefficient = _byte1;
		coefficient = (coefficient *256 )+ _byte2;
 242:	464b      	mov	r3, r9
 244:	021b      	lsls	r3, r3, #8
 246:	1818      	adds	r0, r3, r0
		coefficients_[coeff_num] = coefficient;
 248:	4b08      	ldr	r3, [pc, #32]	; (26c <read_coeff+0x98>)
 24a:	5358      	strh	r0, [r3, r5]
 24c:	3502      	adds	r5, #2
}

void read_coeff(struct spiModule *const module) {

	uint16_t coefficient;
	for (uint8_t coeff_num = 0; coeff_num < 6 ; ++coeff_num ) {
 24e:	2d0c      	cmp	r5, #12
 250:	d1ca      	bne.n	1e8 <read_coeff+0x14>

		coefficient = _byte1;
		coefficient = (coefficient *256 )+ _byte2;
		coefficients_[coeff_num] = coefficient;
	}
}
 252:	bc0c      	pop	{r2, r3}
 254:	4690      	mov	r8, r2
 256:	4699      	mov	r9, r3
 258:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 25a:	46c0      	nop			; (mov r8, r8)
 25c:	0000050d 	.word	0x0000050d
 260:	00000271 	.word	0x00000271
 264:	00000335 	.word	0x00000335
 268:	41004400 	.word	0x41004400
 26c:	20000460 	.word	0x20000460

00000270 <byteOut>:
#include "SaLBitBang.h"



void byteOut(struct spiModule *const module,
             uint8_t byte) {
 270:	b5f0      	push	{r4, r5, r6, r7, lr}
 272:	4647      	mov	r7, r8
 274:	b480      	push	{r7}
 276:	1c07      	adds	r7, r0, #0
 278:	1c0e      	adds	r6, r1, #0

    delay_us(90);
 27a:	205a      	movs	r0, #90	; 0x5a
 27c:	4b2b      	ldr	r3, [pc, #172]	; (32c <byteOut+0xbc>)
 27e:	4798      	blx	r3
 280:	2408      	movs	r4, #8
    for (uint8_t i = 0; i<8; ++i) {
        SaLDigitalOut(module->SCK,PINLOW);
        delay_us(90);
 282:	4d2a      	ldr	r5, [pc, #168]	; (32c <byteOut+0xbc>)
        if (byte & 0x80) {
            SaLDigitalOut(module->MOSI,true);
            delay_us(90);
        } else {
            SaLDigitalOut(module->MOSI,false);
            delay_us(90);
 284:	46a8      	mov	r8, r5
void byteOut(struct spiModule *const module,
             uint8_t byte) {

    delay_us(90);
    for (uint8_t i = 0; i<8; ++i) {
        SaLDigitalOut(module->SCK,PINLOW);
 286:	78bb      	ldrb	r3, [r7, #2]
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 288:	09d9      	lsrs	r1, r3, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 28a:	2200      	movs	r2, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 28c:	2900      	cmp	r1, #0
 28e:	d104      	bne.n	29a <byteOut+0x2a>
        return &(ports[port_index]->Group[group_index]);
 290:	095a      	lsrs	r2, r3, #5
 292:	01d2      	lsls	r2, r2, #7
 294:	4926      	ldr	r1, [pc, #152]	; (330 <byteOut+0xc0>)
 296:	468c      	mov	ip, r1
 298:	4462      	add	r2, ip

void SaLPinMode(uint8_t pin,uint8_t DIR);

static inline void SaLDigitalOut(uint8_t pin, uint8_t level) {
	volatile PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
 29a:	211f      	movs	r1, #31
 29c:	400b      	ands	r3, r1
 29e:	391e      	subs	r1, #30
 2a0:	4099      	lsls	r1, r3
	

	if (level) {
		port->OUTSET.reg = pin_mask;
		} else {
		port->OUTCLR.reg = pin_mask;
 2a2:	6151      	str	r1, [r2, #20]
        delay_us(90);
 2a4:	205a      	movs	r0, #90	; 0x5a
 2a6:	47a8      	blx	r5
        if (byte & 0x80) {
 2a8:	b273      	sxtb	r3, r6
 2aa:	2b00      	cmp	r3, #0
 2ac:	da12      	bge.n	2d4 <byteOut+0x64>
            SaLDigitalOut(module->MOSI,true);
 2ae:	787b      	ldrb	r3, [r7, #1]
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 2b0:	09d9      	lsrs	r1, r3, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 2b2:	2200      	movs	r2, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 2b4:	2900      	cmp	r1, #0
 2b6:	d104      	bne.n	2c2 <byteOut+0x52>
        return &(ports[port_index]->Group[group_index]);
 2b8:	095a      	lsrs	r2, r3, #5
 2ba:	01d2      	lsls	r2, r2, #7
 2bc:	491c      	ldr	r1, [pc, #112]	; (330 <byteOut+0xc0>)
 2be:	468c      	mov	ip, r1
 2c0:	4462      	add	r2, ip

void SaLPinMode(uint8_t pin,uint8_t DIR);

static inline void SaLDigitalOut(uint8_t pin, uint8_t level) {
	volatile PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
 2c2:	211f      	movs	r1, #31
 2c4:	400b      	ands	r3, r1
 2c6:	391e      	subs	r1, #30
 2c8:	4099      	lsls	r1, r3
	

	if (level) {
		port->OUTSET.reg = pin_mask;
 2ca:	6191      	str	r1, [r2, #24]
            delay_us(90);
 2cc:	205a      	movs	r0, #90	; 0x5a
 2ce:	4b17      	ldr	r3, [pc, #92]	; (32c <byteOut+0xbc>)
 2d0:	4798      	blx	r3
 2d2:	e010      	b.n	2f6 <byteOut+0x86>
        } else {
            SaLDigitalOut(module->MOSI,false);
 2d4:	787b      	ldrb	r3, [r7, #1]
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 2d6:	09d9      	lsrs	r1, r3, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 2d8:	2200      	movs	r2, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 2da:	2900      	cmp	r1, #0
 2dc:	d104      	bne.n	2e8 <byteOut+0x78>
        return &(ports[port_index]->Group[group_index]);
 2de:	095a      	lsrs	r2, r3, #5
 2e0:	01d2      	lsls	r2, r2, #7
 2e2:	4913      	ldr	r1, [pc, #76]	; (330 <byteOut+0xc0>)
 2e4:	468c      	mov	ip, r1
 2e6:	4462      	add	r2, ip

void SaLPinMode(uint8_t pin,uint8_t DIR);

static inline void SaLDigitalOut(uint8_t pin, uint8_t level) {
	volatile PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
 2e8:	211f      	movs	r1, #31
 2ea:	400b      	ands	r3, r1
 2ec:	391e      	subs	r1, #30
 2ee:	4099      	lsls	r1, r3
	

	if (level) {
		port->OUTSET.reg = pin_mask;
		} else {
		port->OUTCLR.reg = pin_mask;
 2f0:	6151      	str	r1, [r2, #20]
            delay_us(90);
 2f2:	205a      	movs	r0, #90	; 0x5a
 2f4:	47c0      	blx	r8
        }
        SaLDigitalOut(module->SCK,PINHIGH);
 2f6:	78bb      	ldrb	r3, [r7, #2]
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 2f8:	09d9      	lsrs	r1, r3, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 2fa:	2200      	movs	r2, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 2fc:	2900      	cmp	r1, #0
 2fe:	d104      	bne.n	30a <byteOut+0x9a>
        return &(ports[port_index]->Group[group_index]);
 300:	095a      	lsrs	r2, r3, #5
 302:	01d2      	lsls	r2, r2, #7
 304:	490a      	ldr	r1, [pc, #40]	; (330 <byteOut+0xc0>)
 306:	468c      	mov	ip, r1
 308:	4462      	add	r2, ip

void SaLPinMode(uint8_t pin,uint8_t DIR);

static inline void SaLDigitalOut(uint8_t pin, uint8_t level) {
	volatile PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
 30a:	211f      	movs	r1, #31
 30c:	400b      	ands	r3, r1
 30e:	391e      	subs	r1, #30
 310:	4099      	lsls	r1, r3
	

	if (level) {
		port->OUTSET.reg = pin_mask;
 312:	6191      	str	r1, [r2, #24]
        delay_us(90);
 314:	205a      	movs	r0, #90	; 0x5a
 316:	4b05      	ldr	r3, [pc, #20]	; (32c <byteOut+0xbc>)
 318:	4798      	blx	r3
        byte <<= 1;
 31a:	0076      	lsls	r6, r6, #1
 31c:	b2f6      	uxtb	r6, r6
 31e:	3c01      	subs	r4, #1
 320:	b2e4      	uxtb	r4, r4

void byteOut(struct spiModule *const module,
             uint8_t byte) {

    delay_us(90);
    for (uint8_t i = 0; i<8; ++i) {
 322:	2c00      	cmp	r4, #0
 324:	d1af      	bne.n	286 <byteOut+0x16>
        SaLDigitalOut(module->SCK,PINHIGH);
        delay_us(90);
        byte <<= 1;
    }

}
 326:	bc04      	pop	{r2}
 328:	4690      	mov	r8, r2
 32a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 32c:	0000050d 	.word	0x0000050d
 330:	41004400 	.word	0x41004400

00000334 <getByte>:
        dataBits <<= 1;
    }

}

uint8_t getByte(struct spiModule *const module) {
 334:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 336:	464f      	mov	r7, r9
 338:	4646      	mov	r6, r8
 33a:	b4c0      	push	{r6, r7}
 33c:	1c05      	adds	r5, r0, #0
    uint8_t byte = 0x00;
    delay_us(90);
 33e:	205a      	movs	r0, #90	; 0x5a
 340:	4b26      	ldr	r3, [pc, #152]	; (3dc <getByte+0xa8>)
 342:	4798      	blx	r3
 344:	2408      	movs	r4, #8
    }

}

uint8_t getByte(struct spiModule *const module) {
    uint8_t byte = 0x00;
 346:	2300      	movs	r3, #0
 348:	4699      	mov	r9, r3
    delay_us(90);
    for (uint8_t i = 0; i<8; ++i) {
        SaLDigitalOut(module->SCK,PINLOW);
        delay_us(90);
 34a:	4b24      	ldr	r3, [pc, #144]	; (3dc <getByte+0xa8>)
 34c:	4698      	mov	r8, r3
        byte = (byte << 1 ) | SaLDigitalIn(module->MISO);
        delay_us(90);
 34e:	1c1f      	adds	r7, r3, #0
        SaLDigitalOut(module->SCK,PINHIGH);
        delay_us(90);
 350:	1c1e      	adds	r6, r3, #0

uint8_t getByte(struct spiModule *const module) {
    uint8_t byte = 0x00;
    delay_us(90);
    for (uint8_t i = 0; i<8; ++i) {
        SaLDigitalOut(module->SCK,PINLOW);
 352:	78ab      	ldrb	r3, [r5, #2]
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 354:	09d9      	lsrs	r1, r3, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 356:	2200      	movs	r2, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 358:	2900      	cmp	r1, #0
 35a:	d104      	bne.n	366 <getByte+0x32>
        return &(ports[port_index]->Group[group_index]);
 35c:	095a      	lsrs	r2, r3, #5
 35e:	01d2      	lsls	r2, r2, #7
 360:	491f      	ldr	r1, [pc, #124]	; (3e0 <getByte+0xac>)
 362:	468c      	mov	ip, r1
 364:	4462      	add	r2, ip

void SaLPinMode(uint8_t pin,uint8_t DIR);

static inline void SaLDigitalOut(uint8_t pin, uint8_t level) {
	volatile PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
 366:	211f      	movs	r1, #31
 368:	400b      	ands	r3, r1
 36a:	391e      	subs	r1, #30
 36c:	4099      	lsls	r1, r3
	

	if (level) {
		port->OUTSET.reg = pin_mask;
		} else {
		port->OUTCLR.reg = pin_mask;
 36e:	6151      	str	r1, [r2, #20]
        delay_us(90);
 370:	205a      	movs	r0, #90	; 0x5a
 372:	47c0      	blx	r8
        byte = (byte << 1 ) | SaLDigitalIn(module->MISO);
 374:	464b      	mov	r3, r9
 376:	005b      	lsls	r3, r3, #1
 378:	b2d8      	uxtb	r0, r3
 37a:	782a      	ldrb	r2, [r5, #0]
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 37c:	09d3      	lsrs	r3, r2, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 37e:	2100      	movs	r1, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 380:	2b00      	cmp	r3, #0
 382:	d104      	bne.n	38e <getByte+0x5a>
        return &(ports[port_index]->Group[group_index]);
 384:	0951      	lsrs	r1, r2, #5
 386:	01c9      	lsls	r1, r1, #7
 388:	4b15      	ldr	r3, [pc, #84]	; (3e0 <getByte+0xac>)
 38a:	469c      	mov	ip, r3
 38c:	4461      	add	r1, ip
};

static inline bool SaLDigitalIn(uint8_t pin) {
	PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
	bool level = (port->IN.reg & pin_mask);
 38e:	6a0b      	ldr	r3, [r1, #32]
	}
};

static inline bool SaLDigitalIn(uint8_t pin) {
	PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
 390:	211f      	movs	r1, #31
 392:	400a      	ands	r2, r1
 394:	391e      	subs	r1, #30
 396:	4091      	lsls	r1, r2
	bool level = (port->IN.reg & pin_mask);
 398:	400b      	ands	r3, r1
 39a:	1e5a      	subs	r2, r3, #1
 39c:	4193      	sbcs	r3, r2
 39e:	4303      	orrs	r3, r0
 3a0:	4699      	mov	r9, r3
        delay_us(90);
 3a2:	205a      	movs	r0, #90	; 0x5a
 3a4:	47b8      	blx	r7
        SaLDigitalOut(module->SCK,PINHIGH);
 3a6:	78ab      	ldrb	r3, [r5, #2]
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 3a8:	09d9      	lsrs	r1, r3, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 3aa:	2200      	movs	r2, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 3ac:	2900      	cmp	r1, #0
 3ae:	d104      	bne.n	3ba <getByte+0x86>
        return &(ports[port_index]->Group[group_index]);
 3b0:	095a      	lsrs	r2, r3, #5
 3b2:	01d2      	lsls	r2, r2, #7
 3b4:	490a      	ldr	r1, [pc, #40]	; (3e0 <getByte+0xac>)
 3b6:	468c      	mov	ip, r1
 3b8:	4462      	add	r2, ip

void SaLPinMode(uint8_t pin,uint8_t DIR);

static inline void SaLDigitalOut(uint8_t pin, uint8_t level) {
	volatile PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
 3ba:	211f      	movs	r1, #31
 3bc:	400b      	ands	r3, r1
 3be:	391e      	subs	r1, #30
 3c0:	4099      	lsls	r1, r3
	

	if (level) {
		port->OUTSET.reg = pin_mask;
 3c2:	6191      	str	r1, [r2, #24]
        delay_us(90);
 3c4:	205a      	movs	r0, #90	; 0x5a
 3c6:	47b0      	blx	r6
 3c8:	3c01      	subs	r4, #1
 3ca:	b2e4      	uxtb	r4, r4
}

uint8_t getByte(struct spiModule *const module) {
    uint8_t byte = 0x00;
    delay_us(90);
    for (uint8_t i = 0; i<8; ++i) {
 3cc:	2c00      	cmp	r4, #0
 3ce:	d1c0      	bne.n	352 <getByte+0x1e>
        delay_us(90);
        SaLDigitalOut(module->SCK,PINHIGH);
        delay_us(90);
    }
    return byte;
}
 3d0:	4648      	mov	r0, r9
 3d2:	bc0c      	pop	{r2, r3}
 3d4:	4690      	mov	r8, r2
 3d6:	4699      	mov	r9, r3
 3d8:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 3da:	46c0      	nop			; (mov r8, r8)
 3dc:	0000050d 	.word	0x0000050d
 3e0:	41004400 	.word	0x41004400

000003e4 <getBits>:

uint16_t getBits(struct spiModule *const module,uint8_t bits) {
 3e4:	b5f0      	push	{r4, r5, r6, r7, lr}
 3e6:	4657      	mov	r7, sl
 3e8:	464e      	mov	r6, r9
 3ea:	4645      	mov	r5, r8
 3ec:	b4e0      	push	{r5, r6, r7}
 3ee:	1c05      	adds	r5, r0, #0
 3f0:	1c0e      	adds	r6, r1, #0
    uint16_t data = 0x00;
    delay_us(90);
 3f2:	205a      	movs	r0, #90	; 0x5a
 3f4:	4b27      	ldr	r3, [pc, #156]	; (494 <getBits+0xb0>)
 3f6:	4798      	blx	r3
    for (uint8_t i = 0; i<bits; ++i) {
 3f8:	2e00      	cmp	r6, #0
 3fa:	d044      	beq.n	486 <getBits+0xa2>
 3fc:	2400      	movs	r4, #0
 3fe:	2700      	movs	r7, #0
        SaLDigitalOut(module->SCK,PINLOW);
        delay_us(90);
 400:	4b24      	ldr	r3, [pc, #144]	; (494 <getBits+0xb0>)
 402:	4699      	mov	r9, r3
        data = (data << 1 ) | SaLDigitalIn(module->MISO);
        delay_us(90);
 404:	4698      	mov	r8, r3
        SaLDigitalOut(module->SCK,PINHIGH);
        delay_us(90);
 406:	469a      	mov	sl, r3

uint16_t getBits(struct spiModule *const module,uint8_t bits) {
    uint16_t data = 0x00;
    delay_us(90);
    for (uint8_t i = 0; i<bits; ++i) {
        SaLDigitalOut(module->SCK,PINLOW);
 408:	78ab      	ldrb	r3, [r5, #2]
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 40a:	09d9      	lsrs	r1, r3, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 40c:	2200      	movs	r2, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 40e:	2900      	cmp	r1, #0
 410:	d104      	bne.n	41c <getBits+0x38>
        return &(ports[port_index]->Group[group_index]);
 412:	095a      	lsrs	r2, r3, #5
 414:	01d2      	lsls	r2, r2, #7
 416:	4920      	ldr	r1, [pc, #128]	; (498 <getBits+0xb4>)
 418:	468c      	mov	ip, r1
 41a:	4462      	add	r2, ip

void SaLPinMode(uint8_t pin,uint8_t DIR);

static inline void SaLDigitalOut(uint8_t pin, uint8_t level) {
	volatile PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
 41c:	211f      	movs	r1, #31
 41e:	400b      	ands	r3, r1
 420:	391e      	subs	r1, #30
 422:	4099      	lsls	r1, r3
	

	if (level) {
		port->OUTSET.reg = pin_mask;
		} else {
		port->OUTCLR.reg = pin_mask;
 424:	6151      	str	r1, [r2, #20]
        delay_us(90);
 426:	205a      	movs	r0, #90	; 0x5a
 428:	47c8      	blx	r9
        data = (data << 1 ) | SaLDigitalIn(module->MISO);
 42a:	007b      	lsls	r3, r7, #1
 42c:	b298      	uxth	r0, r3
 42e:	782a      	ldrb	r2, [r5, #0]
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 430:	09d1      	lsrs	r1, r2, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 432:	2300      	movs	r3, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 434:	2900      	cmp	r1, #0
 436:	d104      	bne.n	442 <getBits+0x5e>
        return &(ports[port_index]->Group[group_index]);
 438:	0953      	lsrs	r3, r2, #5
 43a:	01db      	lsls	r3, r3, #7
 43c:	4916      	ldr	r1, [pc, #88]	; (498 <getBits+0xb4>)
 43e:	468c      	mov	ip, r1
 440:	4463      	add	r3, ip
};

static inline bool SaLDigitalIn(uint8_t pin) {
	PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
	bool level = (port->IN.reg & pin_mask);
 442:	6a1b      	ldr	r3, [r3, #32]
	}
};

static inline bool SaLDigitalIn(uint8_t pin) {
	PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
 444:	211f      	movs	r1, #31
 446:	400a      	ands	r2, r1
 448:	391e      	subs	r1, #30
 44a:	4091      	lsls	r1, r2
	bool level = (port->IN.reg & pin_mask);
 44c:	400b      	ands	r3, r1
 44e:	1e5a      	subs	r2, r3, #1
 450:	4193      	sbcs	r3, r2
 452:	4303      	orrs	r3, r0
 454:	1c1f      	adds	r7, r3, #0
        delay_us(90);
 456:	205a      	movs	r0, #90	; 0x5a
 458:	47c0      	blx	r8
        SaLDigitalOut(module->SCK,PINHIGH);
 45a:	78ab      	ldrb	r3, [r5, #2]
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 45c:	09d9      	lsrs	r1, r3, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 45e:	2200      	movs	r2, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 460:	2900      	cmp	r1, #0
 462:	d104      	bne.n	46e <getBits+0x8a>
        return &(ports[port_index]->Group[group_index]);
 464:	095a      	lsrs	r2, r3, #5
 466:	01d2      	lsls	r2, r2, #7
 468:	490b      	ldr	r1, [pc, #44]	; (498 <getBits+0xb4>)
 46a:	468c      	mov	ip, r1
 46c:	4462      	add	r2, ip

void SaLPinMode(uint8_t pin,uint8_t DIR);

static inline void SaLDigitalOut(uint8_t pin, uint8_t level) {
	volatile PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
 46e:	211f      	movs	r1, #31
 470:	400b      	ands	r3, r1
 472:	391e      	subs	r1, #30
 474:	4099      	lsls	r1, r3
	

	if (level) {
		port->OUTSET.reg = pin_mask;
 476:	6191      	str	r1, [r2, #24]
        delay_us(90);
 478:	205a      	movs	r0, #90	; 0x5a
 47a:	47d0      	blx	sl
}

uint16_t getBits(struct spiModule *const module,uint8_t bits) {
    uint16_t data = 0x00;
    delay_us(90);
    for (uint8_t i = 0; i<bits; ++i) {
 47c:	3401      	adds	r4, #1
 47e:	b2e4      	uxtb	r4, r4
 480:	42b4      	cmp	r4, r6
 482:	d1c1      	bne.n	408 <getBits+0x24>
 484:	e000      	b.n	488 <getBits+0xa4>
    }
    return byte;
}

uint16_t getBits(struct spiModule *const module,uint8_t bits) {
    uint16_t data = 0x00;
 486:	2700      	movs	r7, #0
        delay_us(90);
        SaLDigitalOut(module->SCK,PINHIGH);
        delay_us(90);
    }
    return data;
 488:	1c38      	adds	r0, r7, #0
 48a:	bc1c      	pop	{r2, r3, r4}
 48c:	4690      	mov	r8, r2
 48e:	4699      	mov	r9, r3
 490:	46a2      	mov	sl, r4
 492:	bdf0      	pop	{r4, r5, r6, r7, pc}
 494:	0000050d 	.word	0x0000050d
 498:	41004400 	.word	0x41004400

0000049c <SaLPlayTone>:

#include <SaLBuzzer.h>


void SaLPlayTone(int16_t tone_) {
 49c:	b5f0      	push	{r4, r5, r6, r7, lr}
 49e:	464f      	mov	r7, r9
 4a0:	4646      	mov	r6, r8
 4a2:	b4c0      	push	{r6, r7}
 4a4:	b083      	sub	sp, #12
 4a6:	4680      	mov	r8, r0
	int32_t duration = 100000;
	
    while (elapsed_time < duration) {
		
		SaLDigitalOut(BUZZER,true);
		delay_us(tone_/2);
 4a8:	0fc6      	lsrs	r6, r0, #31
 4aa:	4446      	add	r6, r8
 4ac:	1073      	asrs	r3, r6, #1
 4ae:	9301      	str	r3, [sp, #4]


void SaLPlayTone(int16_t tone_) {

	
	int32_t elapsed_time = 0;
 4b0:	2400      	movs	r4, #0
 4b2:	4f0b      	ldr	r7, [pc, #44]	; (4e0 <SaLPlayTone+0x44>)
 4b4:	2380      	movs	r3, #128	; 0x80
 4b6:	015b      	lsls	r3, r3, #5
 4b8:	4699      	mov	r9, r3
 4ba:	1c1e      	adds	r6, r3, #0
 4bc:	61be      	str	r6, [r7, #24]
	int32_t duration = 100000;
	
    while (elapsed_time < duration) {
		
		SaLDigitalOut(BUZZER,true);
		delay_us(tone_/2);
 4be:	9801      	ldr	r0, [sp, #4]
 4c0:	4d08      	ldr	r5, [pc, #32]	; (4e4 <SaLPlayTone+0x48>)
 4c2:	47a8      	blx	r5
		} else {
		port->OUTCLR.reg = pin_mask;
 4c4:	464b      	mov	r3, r9
 4c6:	617b      	str	r3, [r7, #20]
		
		 SaLDigitalOut(BUZZER, false);
		 delay_us(tone_/2);
 4c8:	9801      	ldr	r0, [sp, #4]
 4ca:	47a8      	blx	r5
 4cc:	4444      	add	r4, r8

	
	int32_t elapsed_time = 0;
	int32_t duration = 100000;
	
    while (elapsed_time < duration) {
 4ce:	4b06      	ldr	r3, [pc, #24]	; (4e8 <SaLPlayTone+0x4c>)
 4d0:	429c      	cmp	r4, r3
 4d2:	ddf3      	ble.n	4bc <SaLPlayTone+0x20>
	
	
	}


 4d4:	b003      	add	sp, #12
 4d6:	bc0c      	pop	{r2, r3}
 4d8:	4690      	mov	r8, r2
 4da:	4699      	mov	r9, r3
 4dc:	bdf0      	pop	{r4, r5, r6, r7, pc}
 4de:	46c0      	nop			; (mov r8, r8)
 4e0:	41004400 	.word	0x41004400
 4e4:	0000050d 	.word	0x0000050d
 4e8:	0001869f 	.word	0x0001869f

000004ec <SaLDelayInit>:
static uint32_t cycles_per_ms = 48000000UL / 1000;
static uint32_t cycles_per_us = 48000000UL / 1000000;

void SaLDelayInit(void) {
    cycles_per_ms = 41900000UL;
    cycles_per_ms /= 1000;
 4ec:	4b04      	ldr	r3, [pc, #16]	; (500 <SaLDelayInit+0x14>)
 4ee:	4a05      	ldr	r2, [pc, #20]	; (504 <SaLDelayInit+0x18>)
 4f0:	601a      	str	r2, [r3, #0]
    cycles_per_us = cycles_per_ms / 1000;
 4f2:	2229      	movs	r2, #41	; 0x29
 4f4:	605a      	str	r2, [r3, #4]

    SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk | SysTick_CTRL_ENABLE_Msk;
 4f6:	3a24      	subs	r2, #36	; 0x24
 4f8:	4b03      	ldr	r3, [pc, #12]	; (508 <SaLDelayInit+0x1c>)
 4fa:	601a      	str	r2, [r3, #0]
}
 4fc:	4770      	bx	lr
 4fe:	46c0      	nop			; (mov r8, r8)
 500:	20000000 	.word	0x20000000
 504:	0000a3ac 	.word	0x0000a3ac
 508:	e000e010 	.word	0xe000e010

0000050c <delay_us>:
 * \brief Delay loop to delay at least n number of microseconds
 *
 * \param n  Number of microseconds to wait
 */
void delay_us(
    uint32_t n) {
 50c:	b530      	push	{r4, r5, lr}
    while (n--) {
        /* Devide up to blocks of 10u */
        delay_cycles(cycles_per_us);
 50e:	4b08      	ldr	r3, [pc, #32]	; (530 <delay_us+0x24>)
 510:	685c      	ldr	r4, [r3, #4]
void SaLDelayInit(void);

static inline void delay_cycles(
    const uint32_t n) {
    if (n > 0) {
        SysTick->LOAD = n;
 512:	4a08      	ldr	r2, [pc, #32]	; (534 <delay_us+0x28>)
        SysTick->VAL = 0;
 514:	2500      	movs	r5, #0

        while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
 516:	2180      	movs	r1, #128	; 0x80
 518:	0249      	lsls	r1, r1, #9
 *
 * \param n  Number of microseconds to wait
 */
void delay_us(
    uint32_t n) {
    while (n--) {
 51a:	e006      	b.n	52a <delay_us+0x1e>

void SaLDelayInit(void);

static inline void delay_cycles(
    const uint32_t n) {
    if (n > 0) {
 51c:	2c00      	cmp	r4, #0
 51e:	d004      	beq.n	52a <delay_us+0x1e>
        SysTick->LOAD = n;
 520:	6054      	str	r4, [r2, #4]
        SysTick->VAL = 0;
 522:	6095      	str	r5, [r2, #8]

        while (!(SysTick->CTRL & SysTick_CTRL_COUNTFLAG_Msk)) {
 524:	6813      	ldr	r3, [r2, #0]
 526:	420b      	tst	r3, r1
 528:	d0fc      	beq.n	524 <delay_us+0x18>
 52a:	3801      	subs	r0, #1
 52c:	d2f6      	bcs.n	51c <delay_us+0x10>
        /* Devide up to blocks of 10u */
        delay_cycles(cycles_per_us);
    }
}
 52e:	bd30      	pop	{r4, r5, pc}
 530:	20000000 	.word	0x20000000
 534:	e000e010 	.word	0xe000e010

00000538 <SaLPinMode>:


#include <SaLPort.h>

void SaLPinMode(uint8_t pin,uint8_t DIR) {
 538:	b510      	push	{r4, lr}
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 53a:	09c2      	lsrs	r2, r0, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 53c:	2300      	movs	r3, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 53e:	2a00      	cmp	r2, #0
 540:	d104      	bne.n	54c <SaLPinMode+0x14>
        return &(ports[port_index]->Group[group_index]);
 542:	0943      	lsrs	r3, r0, #5
 544:	01db      	lsls	r3, r3, #7
 546:	4a11      	ldr	r2, [pc, #68]	; (58c <SaLPinMode+0x54>)
 548:	4694      	mov	ip, r2
 54a:	4463      	add	r3, ip
    PortGroup *const port = SaLGetPort(pin);
    uint32_t pin_mask = (1UL << (pin % 32));
 54c:	221f      	movs	r2, #31
 54e:	4002      	ands	r2, r0
 550:	2401      	movs	r4, #1
 552:	4094      	lsls	r4, r2

    if ( DIR == OUTPUT) {
 554:	2901      	cmp	r1, #1
 556:	d105      	bne.n	564 <SaLPinMode+0x2c>
        port->DIRSET.reg = pin_mask;
 558:	609c      	str	r4, [r3, #8]
        port->PINCFG[pin].reg = 0;
 55a:	1818      	adds	r0, r3, r0
 55c:	3040      	adds	r0, #64	; 0x40
 55e:	2300      	movs	r3, #0
 560:	7003      	strb	r3, [r0, #0]
 562:	e012      	b.n	58a <SaLPinMode+0x52>

    } else if(DIR == INPUT) {
 564:	2900      	cmp	r1, #0
 566:	d109      	bne.n	57c <SaLPinMode+0x44>
        port->DIRCLR.reg = pin_mask;
 568:	605c      	str	r4, [r3, #4]
        port->PINCFG[pin].reg = PORT_PINCFG_INEN;
 56a:	1818      	adds	r0, r3, r0
 56c:	3040      	adds	r0, #64	; 0x40
 56e:	2302      	movs	r3, #2
 570:	7003      	strb	r3, [r0, #0]
        port->PINCFG[pin].reg |= PORT_PINCFG_PULLEN;
 572:	7802      	ldrb	r2, [r0, #0]
 574:	3302      	adds	r3, #2
 576:	4313      	orrs	r3, r2
 578:	7003      	strb	r3, [r0, #0]
 57a:	e006      	b.n	58a <SaLPinMode+0x52>
    } else if (DIR == OUTSTRONG) {
 57c:	2903      	cmp	r1, #3
 57e:	d104      	bne.n	58a <SaLPinMode+0x52>
        port->DIRSET.reg = pin_mask;
 580:	609c      	str	r4, [r3, #8]
        port->PINCFG[pin].reg = 0x40;
 582:	1818      	adds	r0, r3, r0
 584:	3040      	adds	r0, #64	; 0x40
 586:	2340      	movs	r3, #64	; 0x40
 588:	7003      	strb	r3, [r0, #0]

    }
 58a:	bd10      	pop	{r4, pc}
 58c:	41004400 	.word	0x41004400

00000590 <Dummy_Handler>:
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_IPSR(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, ipsr" : "=r" (result) );
 590:	f3ef 8305 	mrs	r3, IPSR
 594:	e7fc      	b.n	590 <Dummy_Handler>
 596:	46c0      	nop			; (mov r8, r8)

00000598 <Reset_Handler>:
/**
 * \brief This is the code that gets called on processor reset.
 * To initialize the device, and call the main() routine.
 */
void Reset_Handler(void)
{
 598:	b570      	push	{r4, r5, r6, lr}

        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
 59a:	4b2e      	ldr	r3, [pc, #184]	; (654 <Reset_Handler+0xbc>)
 59c:	4a2e      	ldr	r2, [pc, #184]	; (658 <Reset_Handler+0xc0>)
 59e:	429a      	cmp	r2, r3
 5a0:	d003      	beq.n	5aa <Reset_Handler+0x12>
                for (; pDest < &_erelocate;) {
 5a2:	4b2e      	ldr	r3, [pc, #184]	; (65c <Reset_Handler+0xc4>)
 5a4:	4a2b      	ldr	r2, [pc, #172]	; (654 <Reset_Handler+0xbc>)
 5a6:	429a      	cmp	r2, r3
 5a8:	d304      	bcc.n	5b4 <Reset_Handler+0x1c>
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
 5aa:	4b2d      	ldr	r3, [pc, #180]	; (660 <Reset_Handler+0xc8>)
 5ac:	4a2d      	ldr	r2, [pc, #180]	; (664 <Reset_Handler+0xcc>)
 5ae:	429a      	cmp	r2, r3
 5b0:	d310      	bcc.n	5d4 <Reset_Handler+0x3c>
 5b2:	e01e      	b.n	5f2 <Reset_Handler+0x5a>
 5b4:	4a2c      	ldr	r2, [pc, #176]	; (668 <Reset_Handler+0xd0>)
 5b6:	4b29      	ldr	r3, [pc, #164]	; (65c <Reset_Handler+0xc4>)
 5b8:	3303      	adds	r3, #3
 5ba:	1a9b      	subs	r3, r3, r2
 5bc:	089b      	lsrs	r3, r3, #2
 5be:	3301      	adds	r3, #1
 5c0:	009b      	lsls	r3, r3, #2
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
 5c2:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
 5c4:	4823      	ldr	r0, [pc, #140]	; (654 <Reset_Handler+0xbc>)
 5c6:	4924      	ldr	r1, [pc, #144]	; (658 <Reset_Handler+0xc0>)
 5c8:	588c      	ldr	r4, [r1, r2]
 5ca:	5084      	str	r4, [r0, r2]
 5cc:	3204      	adds	r2, #4
        /* Initialize the relocate segment */
        pSrc = &_etext;
        pDest = &_srelocate;

        if (pSrc != pDest) {
                for (; pDest < &_erelocate;) {
 5ce:	429a      	cmp	r2, r3
 5d0:	d1fa      	bne.n	5c8 <Reset_Handler+0x30>
 5d2:	e7ea      	b.n	5aa <Reset_Handler+0x12>
 5d4:	4a25      	ldr	r2, [pc, #148]	; (66c <Reset_Handler+0xd4>)
 5d6:	4b22      	ldr	r3, [pc, #136]	; (660 <Reset_Handler+0xc8>)
 5d8:	3303      	adds	r3, #3
 5da:	1a9b      	subs	r3, r3, r2
 5dc:	089b      	lsrs	r3, r3, #2
 5de:	3301      	adds	r3, #1
 5e0:	009b      	lsls	r3, r3, #2
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
 5e2:	2200      	movs	r2, #0
                *pDest++ = 0;
 5e4:	481f      	ldr	r0, [pc, #124]	; (664 <Reset_Handler+0xcc>)
 5e6:	2100      	movs	r1, #0
 5e8:	1814      	adds	r4, r2, r0
 5ea:	6021      	str	r1, [r4, #0]
 5ec:	3204      	adds	r2, #4
                        *pDest++ = *pSrc++;
                }
        }

        /* Clear the zero segment */
        for (pDest = &_szero; pDest < &_ezero;) {
 5ee:	429a      	cmp	r2, r3
 5f0:	d1fa      	bne.n	5e8 <Reset_Handler+0x50>
                *pDest++ = 0;
        }

        /* Set the vector table base address */
        pSrc = (uint32_t *) & _sfixed;
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
 5f2:	4a1f      	ldr	r2, [pc, #124]	; (670 <Reset_Handler+0xd8>)
 5f4:	21ff      	movs	r1, #255	; 0xff
 5f6:	4b1f      	ldr	r3, [pc, #124]	; (674 <Reset_Handler+0xdc>)
 5f8:	438b      	bics	r3, r1
 5fa:	6093      	str	r3, [r2, #8]

        /* Change default QOS values to have the best performance and correct USB behaviour */
        SBMATRIX->SFR[SBMATRIX_SLAVE_HMCRAMC0].reg = 2;
 5fc:	39fd      	subs	r1, #253	; 0xfd
 5fe:	2390      	movs	r3, #144	; 0x90
 600:	005b      	lsls	r3, r3, #1
 602:	4a1d      	ldr	r2, [pc, #116]	; (678 <Reset_Handler+0xe0>)
 604:	50d1      	str	r1, [r2, r3]
#if defined(ID_USB)
        USB->DEVICE.QOSCTRL.bit.CQOS = 2;
 606:	481d      	ldr	r0, [pc, #116]	; (67c <Reset_Handler+0xe4>)
 608:	78c3      	ldrb	r3, [r0, #3]
 60a:	2403      	movs	r4, #3
 60c:	43a3      	bics	r3, r4
 60e:	2202      	movs	r2, #2
 610:	4313      	orrs	r3, r2
 612:	70c3      	strb	r3, [r0, #3]
        USB->DEVICE.QOSCTRL.bit.DQOS = 2;
 614:	78c3      	ldrb	r3, [r0, #3]
 616:	260c      	movs	r6, #12
 618:	43b3      	bics	r3, r6
 61a:	2108      	movs	r1, #8
 61c:	430b      	orrs	r3, r1
 61e:	70c3      	strb	r3, [r0, #3]
#endif
        DMAC->QOSCTRL.bit.DQOS = 2;
 620:	4b17      	ldr	r3, [pc, #92]	; (680 <Reset_Handler+0xe8>)
 622:	7b98      	ldrb	r0, [r3, #14]
 624:	2530      	movs	r5, #48	; 0x30
 626:	43a8      	bics	r0, r5
 628:	1c05      	adds	r5, r0, #0
 62a:	2020      	movs	r0, #32
 62c:	4328      	orrs	r0, r5
 62e:	7398      	strb	r0, [r3, #14]
        DMAC->QOSCTRL.bit.FQOS = 2;
 630:	7b98      	ldrb	r0, [r3, #14]
 632:	43b0      	bics	r0, r6
 634:	4301      	orrs	r1, r0
 636:	7399      	strb	r1, [r3, #14]
        DMAC->QOSCTRL.bit.WRBQOS = 2;
 638:	7b99      	ldrb	r1, [r3, #14]
 63a:	43a1      	bics	r1, r4
 63c:	430a      	orrs	r2, r1
 63e:	739a      	strb	r2, [r3, #14]

        /* Overwriting the default value of the NVMCTRL.CTRLB.MANW bit (errata reference 13134) */
        NVMCTRL->CTRLB.bit.MANW = 1;
 640:	4a10      	ldr	r2, [pc, #64]	; (684 <Reset_Handler+0xec>)
 642:	6851      	ldr	r1, [r2, #4]
 644:	2380      	movs	r3, #128	; 0x80
 646:	430b      	orrs	r3, r1
 648:	6053      	str	r3, [r2, #4]

        /* Initialize the C library */
        __libc_init_array();
 64a:	4b0f      	ldr	r3, [pc, #60]	; (688 <Reset_Handler+0xf0>)
 64c:	4798      	blx	r3

        /* Branch to main function */
        main();
 64e:	4b0f      	ldr	r3, [pc, #60]	; (68c <Reset_Handler+0xf4>)
 650:	4798      	blx	r3

        /* Infinite loop */
        while (1);
 652:	e7fe      	b.n	652 <Reset_Handler+0xba>
 654:	20000000 	.word	0x20000000
 658:	00000c20 	.word	0x00000c20
 65c:	20000438 	.word	0x20000438
 660:	200006c4 	.word	0x200006c4
 664:	20000438 	.word	0x20000438
 668:	20000004 	.word	0x20000004
 66c:	2000043c 	.word	0x2000043c
 670:	e000ed00 	.word	0xe000ed00
 674:	00000000 	.word	0x00000000
 678:	41007000 	.word	0x41007000
 67c:	41005000 	.word	0x41005000
 680:	41004800 	.word	0x41004800
 684:	41004000 	.word	0x41004000
 688:	00000a7d 	.word	0x00000a7d
 68c:	00000971 	.word	0x00000971

00000690 <SystemInit>:
 *         Initialize the System and update the SystemCoreClock variable.
 */
void SystemInit(void)
{
	// Keep the default device state after reset
	SystemCoreClock = __SYSTEM_CLOCK;
 690:	4a01      	ldr	r2, [pc, #4]	; (698 <SystemInit+0x8>)
 692:	4b02      	ldr	r3, [pc, #8]	; (69c <SystemInit+0xc>)
 694:	601a      	str	r2, [r3, #0]
	return;
}
 696:	4770      	bx	lr
 698:	000f4240 	.word	0x000f4240
 69c:	20000008 	.word	0x20000008

000006a0 <ClockInit>:



void ClockInit() {

    SYSCTRL->INTFLAG.reg = SYSCTRL_INTFLAG_BOD33RDY | SYSCTRL_INTFLAG_BOD33DET |
 6a0:	491a      	ldr	r1, [pc, #104]	; (70c <ClockInit+0x6c>)
 6a2:	23c2      	movs	r3, #194	; 0xc2
 6a4:	00db      	lsls	r3, r3, #3
 6a6:	608b      	str	r3, [r1, #8]
                           SYSCTRL_INTFLAG_DFLLRDY;

    NVMCTRL->CTRLB.bit.RWS = 1;
 6a8:	4819      	ldr	r0, [pc, #100]	; (710 <ClockInit+0x70>)
 6aa:	6843      	ldr	r3, [r0, #4]
 6ac:	221e      	movs	r2, #30
 6ae:	4393      	bics	r3, r2
 6b0:	3a1c      	subs	r2, #28
 6b2:	4313      	orrs	r3, r2
 6b4:	6043      	str	r3, [r0, #4]

    // start and enable external 32k crystal
    SYSCTRL->XOSC32K.reg = SYSCTRL_XOSC32K_ENABLE |
 6b6:	4b17      	ldr	r3, [pc, #92]	; (714 <ClockInit+0x74>)
 6b8:	828b      	strh	r3, [r1, #20]
                           SYSCTRL_XOSC32K_XTALEN |
                           SYSCTRL_XOSC32K_EN32K |
                           ( 6 << SYSCTRL_XOSC32K_STARTUP_Pos);
    //wait for crystal to warm up
    while((SYSCTRL->PCLKSR.reg & (SYSCTRL_PCLKSR_XOSC32KRDY)) == 0);
 6ba:	68cb      	ldr	r3, [r1, #12]
 6bc:	421a      	tst	r2, r3
 6be:	d0fc      	beq.n	6ba <ClockInit+0x1a>
    GCLK->GENDIV.reg = GCLK_GENDIV_ID(1) |
 6c0:	4b15      	ldr	r3, [pc, #84]	; (718 <ClockInit+0x78>)
 6c2:	2202      	movs	r2, #2
 6c4:	32ff      	adds	r2, #255	; 0xff
 6c6:	609a      	str	r2, [r3, #8]
                       GCLK_GENDIV_DIV(1);
    GCLK->GENCTRL.reg = GCLK_GENCTRL_ID(1) |
 6c8:	4a14      	ldr	r2, [pc, #80]	; (71c <ClockInit+0x7c>)
 6ca:	605a      	str	r2, [r3, #4]
                        GCLK_GENCTRL_SRC_XOSC32K |
                        GCLK_GENCTRL_GENEN;
    GCLK->CLKCTRL.reg = GCLK_CLKCTRL_GEN(1) |
 6cc:	2282      	movs	r2, #130	; 0x82
 6ce:	01d2      	lsls	r2, r2, #7
 6d0:	805a      	strh	r2, [r3, #2]
                        GCLK_CLKCTRL_CLKEN |
                        GCLK_CLKCTRL_ID_DFLL48;

    //Configure the FDLL48MHz FLL, we will use this to provide a clock to the CPU
    //Set the course and fine step sizes, these should be less than 50% of the values used for the course and fine values (P150)
    SYSCTRL->DFLLCTRL.reg = (SYSCTRL_DFLLCTRL_ENABLE); //Enable the DFLL
 6d2:	4b0e      	ldr	r3, [pc, #56]	; (70c <ClockInit+0x6c>)
 6d4:	2202      	movs	r2, #2
 6d6:	849a      	strh	r2, [r3, #36]	; 0x24
    SYSCTRL->DFLLMUL.reg = (SYSCTRL_DFLLMUL_CSTEP(7) | SYSCTRL_DFLLMUL_FSTEP(30));
 6d8:	4a11      	ldr	r2, [pc, #68]	; (720 <ClockInit+0x80>)
 6da:	62da      	str	r2, [r3, #44]	; 0x2c
    SYSCTRL->DFLLMUL.reg |= (SYSCTRL_DFLLMUL_MUL(1280));
 6dc:	6ada      	ldr	r2, [r3, #44]	; 0x2c
 6de:	21a0      	movs	r1, #160	; 0xa0
 6e0:	00c9      	lsls	r1, r1, #3
 6e2:	430a      	orrs	r2, r1
 6e4:	62da      	str	r2, [r3, #44]	; 0x2c
    SYSCTRL->DFLLCTRL.reg |= (SYSCTRL_DFLLCTRL_MODE);
 6e6:	8c99      	ldrh	r1, [r3, #36]	; 0x24
 6e8:	2204      	movs	r2, #4
 6ea:	430a      	orrs	r2, r1
 6ec:	849a      	strh	r2, [r3, #36]	; 0x24

    //Wait and see if the DFLL output is good . . .
    while((SYSCTRL->PCLKSR.reg & (SYSCTRL_PCLKSR_DFLLRDY)) == 0);
 6ee:	1c19      	adds	r1, r3, #0
 6f0:	2210      	movs	r2, #16
 6f2:	68cb      	ldr	r3, [r1, #12]
 6f4:	421a      	tst	r2, r3
 6f6:	d0fc      	beq.n	6f2 <ClockInit+0x52>

    //For generic clock generator 0, select the DFLL48 Clock as input
    GCLK->GENDIV.reg  = (GCLK_GENDIV_DIV(2)  | GCLK_GENDIV_ID(0));
 6f8:	4b07      	ldr	r3, [pc, #28]	; (718 <ClockInit+0x78>)
 6fa:	2280      	movs	r2, #128	; 0x80
 6fc:	0092      	lsls	r2, r2, #2
 6fe:	609a      	str	r2, [r3, #8]
    GCLK->GENCTRL.reg = (GCLK_GENCTRL_ID(0)  | (GCLK_GENCTRL_SRC_DFLL48M) | (GCLK_GENCTRL_GENEN));
 700:	4a08      	ldr	r2, [pc, #32]	; (724 <ClockInit+0x84>)
 702:	605a      	str	r2, [r3, #4]
    GCLK->CLKCTRL.reg = (GCLK_CLKCTRL_GEN(0) | GCLK_CLKCTRL_CLKEN ) ;
 704:	2280      	movs	r2, #128	; 0x80
 706:	01d2      	lsls	r2, r2, #7
 708:	805a      	strh	r2, [r3, #2]
	
	
}
 70a:	4770      	bx	lr
 70c:	40000800 	.word	0x40000800
 710:	41004000 	.word	0x41004000
 714:	0000060e 	.word	0x0000060e
 718:	40000c00 	.word	0x40000c00
 71c:	00010501 	.word	0x00010501
 720:	1c1e0000 	.word	0x1c1e0000
 724:	00010700 	.word	0x00010700

00000728 <PinConfig>:

void PinConfig() {
 728:	b510      	push	{r4, lr}

    /* temp SS HIGH for other peripherals */
    SaLPinMode(PIN_PA07,INPUT);
 72a:	2007      	movs	r0, #7
 72c:	2100      	movs	r1, #0
 72e:	4c09      	ldr	r4, [pc, #36]	; (754 <PinConfig+0x2c>)
 730:	47a0      	blx	r4
    SaLPinMode(PIN_PA10,OUTPUT);
 732:	200a      	movs	r0, #10
 734:	2101      	movs	r1, #1
 736:	47a0      	blx	r4
    SaLPinMode(PIN_PA08,OUTPUT);
 738:	2008      	movs	r0, #8
 73a:	2101      	movs	r1, #1
 73c:	47a0      	blx	r4
    SaLPinMode(BUZZER,OUTSTRONG);
 73e:	200c      	movs	r0, #12
 740:	2103      	movs	r1, #3
 742:	47a0      	blx	r4
	volatile PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
	

	if (level) {
		port->OUTSET.reg = pin_mask;
 744:	4b04      	ldr	r3, [pc, #16]	; (758 <PinConfig+0x30>)
 746:	2280      	movs	r2, #128	; 0x80
 748:	00d2      	lsls	r2, r2, #3
 74a:	619a      	str	r2, [r3, #24]
 74c:	2280      	movs	r2, #128	; 0x80
 74e:	0052      	lsls	r2, r2, #1
 750:	619a      	str	r2, [r3, #24]
    SaLDigitalOut(PIN_PA10,true);
    SaLDigitalOut(PIN_PA08,true);
}
 752:	bd10      	pop	{r4, pc}
 754:	00000539 	.word	0x00000539
 758:	41004400 	.word	0x41004400

0000075c <baroModuleSetup>:

struct spiModule baroModuleSetup() {
 75c:	b538      	push	{r3, r4, r5, lr}
 75e:	1c04      	adds	r4, r0, #0
    module->MOSI		= MOSI_PIN;
    module->MISO		= MISO_pin;
    module->SCK		    = SCK_PIN;
    module->SS			= SS_PIN;

    SaLPinMode(module->MOSI,OUTPUT);
 760:	200d      	movs	r0, #13
 762:	2101      	movs	r1, #1
 764:	4d0d      	ldr	r5, [pc, #52]	; (79c <baroModuleSetup+0x40>)
 766:	47a8      	blx	r5
    SaLPinMode(module->SCK ,OUTPUT);
 768:	200f      	movs	r0, #15
 76a:	2101      	movs	r1, #1
 76c:	47a8      	blx	r5
    SaLPinMode(module->SS,  OUTPUT);
 76e:	2009      	movs	r0, #9
 770:	2101      	movs	r1, #1
 772:	47a8      	blx	r5
    SaLPinMode(module->MISO,INPUT);
 774:	200e      	movs	r0, #14
 776:	2100      	movs	r1, #0
 778:	47a8      	blx	r5
 77a:	2280      	movs	r2, #128	; 0x80
 77c:	0092      	lsls	r2, r2, #2
 77e:	4b08      	ldr	r3, [pc, #32]	; (7a0 <baroModuleSetup+0x44>)
 780:	619a      	str	r2, [r3, #24]
                    MS5607_MOSIPIN,
                    MS5607_MISOPIN,
                    MS5607_SCKPIN,
                    MS5607_SLAVE_SELECT_PIN);

    return baroModule;
 782:	230e      	movs	r3, #14
 784:	7023      	strb	r3, [r4, #0]
 786:	3b01      	subs	r3, #1
 788:	7063      	strb	r3, [r4, #1]
 78a:	3302      	adds	r3, #2
 78c:	70a3      	strb	r3, [r4, #2]
 78e:	3b06      	subs	r3, #6
 790:	70e3      	strb	r3, [r4, #3]
 792:	2300      	movs	r3, #0
 794:	7123      	strb	r3, [r4, #4]
 796:	7163      	strb	r3, [r4, #5]
}
 798:	1c20      	adds	r0, r4, #0
 79a:	bd38      	pop	{r3, r4, r5, pc}
 79c:	00000539 	.word	0x00000539
 7a0:	41004400 	.word	0x41004400

000007a4 <accelModuleSetup>:

struct spiModule accelModuleSetup() {
 7a4:	b538      	push	{r3, r4, r5, lr}
 7a6:	1c04      	adds	r4, r0, #0
    module->MOSI		= MOSI_PIN;
    module->MISO		= MISO_pin;
    module->SCK		    = SCK_PIN;
    module->SS			= SS_PIN;

    SaLPinMode(module->MOSI,OUTPUT);
 7a8:	200d      	movs	r0, #13
 7aa:	2101      	movs	r1, #1
 7ac:	4d0d      	ldr	r5, [pc, #52]	; (7e4 <accelModuleSetup+0x40>)
 7ae:	47a8      	blx	r5
    SaLPinMode(module->SCK ,OUTPUT);
 7b0:	200f      	movs	r0, #15
 7b2:	2101      	movs	r1, #1
 7b4:	47a8      	blx	r5
    SaLPinMode(module->SS,  OUTPUT);
 7b6:	2010      	movs	r0, #16
 7b8:	2101      	movs	r1, #1
 7ba:	47a8      	blx	r5
    SaLPinMode(module->MISO,INPUT);
 7bc:	200e      	movs	r0, #14
 7be:	2100      	movs	r1, #0
 7c0:	47a8      	blx	r5
 7c2:	2280      	movs	r2, #128	; 0x80
 7c4:	0252      	lsls	r2, r2, #9
 7c6:	4b08      	ldr	r3, [pc, #32]	; (7e8 <accelModuleSetup+0x44>)
 7c8:	619a      	str	r2, [r3, #24]
                    ADXL345_MOSIPIN,
                    ADXL345_MISOPIN,
                    ADXL345_SCKPIN,
                    ADXL345_SLAVE_SELECT_PIN);

    return accelModule;
 7ca:	230e      	movs	r3, #14
 7cc:	7023      	strb	r3, [r4, #0]
 7ce:	3b01      	subs	r3, #1
 7d0:	7063      	strb	r3, [r4, #1]
 7d2:	3302      	adds	r3, #2
 7d4:	70a3      	strb	r3, [r4, #2]
 7d6:	3301      	adds	r3, #1
 7d8:	70e3      	strb	r3, [r4, #3]
 7da:	2300      	movs	r3, #0
 7dc:	7123      	strb	r3, [r4, #4]
 7de:	7163      	strb	r3, [r4, #5]
}
 7e0:	1c20      	adds	r0, r4, #0
 7e2:	bd38      	pop	{r3, r4, r5, pc}
 7e4:	00000539 	.word	0x00000539
 7e8:	41004400 	.word	0x41004400

000007ec <GPSmoduleSetup>:

struct USARTModule GPSmoduleSetup() {
 7ec:	b538      	push	{r3, r4, r5, lr}
 7ee:	1c04      	adds	r4, r0, #0
    module->TX				= TX_PIN;
    module->RX				= RX_PIN;
    module->BAUD			= BAUDRATE;
    module->SERCOMNUMBER	= SERCOMNUM;

    SaLPinMode(module->TX,OUTPUT);
 7f0:	2037      	movs	r0, #55	; 0x37
 7f2:	2101      	movs	r1, #1
 7f4:	4d07      	ldr	r5, [pc, #28]	; (814 <GPSmoduleSetup+0x28>)
 7f6:	47a8      	blx	r5
    SaLPinMode(module->RX,INPUT);
 7f8:	2036      	movs	r0, #54	; 0x36
 7fa:	2100      	movs	r1, #0
 7fc:	47a8      	blx	r5
                      PIN_PB23,
                      PIN_PB22,
                      5700,
                      5);

    return gpsModule;
 7fe:	2337      	movs	r3, #55	; 0x37
 800:	7023      	strb	r3, [r4, #0]
 802:	3b01      	subs	r3, #1
 804:	7063      	strb	r3, [r4, #1]
 806:	4b04      	ldr	r3, [pc, #16]	; (818 <GPSmoduleSetup+0x2c>)
 808:	8063      	strh	r3, [r4, #2]
 80a:	2305      	movs	r3, #5
 80c:	7123      	strb	r3, [r4, #4]
}
 80e:	1c20      	adds	r0, r4, #0
 810:	bd38      	pop	{r3, r4, r5, pc}
 812:	46c0      	nop			; (mov r8, r8)
 814:	00000539 	.word	0x00000539
 818:	00001644 	.word	0x00001644

0000081c <initAccelSensor>:

void initAccelSensor(struct spiModule *const module) {
 81c:	b538      	push	{r3, r4, r5, lr}
 81e:	1c04      	adds	r4, r0, #0
    /*=========================================================================
    					accel init stuff
    -----------------------------------------------------------------------*/
    SaLDigitalOut(module->SS,false);
 820:	78c3      	ldrb	r3, [r0, #3]
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 822:	09d9      	lsrs	r1, r3, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 824:	2200      	movs	r2, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 826:	2900      	cmp	r1, #0
 828:	d104      	bne.n	834 <initAccelSensor+0x18>
        return &(ports[port_index]->Group[group_index]);
 82a:	095a      	lsrs	r2, r3, #5
 82c:	01d2      	lsls	r2, r2, #7
 82e:	4934      	ldr	r1, [pc, #208]	; (900 <initAccelSensor+0xe4>)
 830:	468c      	mov	ip, r1
 832:	4462      	add	r2, ip

void SaLPinMode(uint8_t pin,uint8_t DIR);

static inline void SaLDigitalOut(uint8_t pin, uint8_t level) {
	volatile PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
 834:	211f      	movs	r1, #31
 836:	400b      	ands	r3, r1
 838:	391e      	subs	r1, #30
 83a:	4099      	lsls	r1, r3
	

	if (level) {
		port->OUTSET.reg = pin_mask;
		} else {
		port->OUTCLR.reg = pin_mask;
 83c:	6151      	str	r1, [r2, #20]
    byteOut(module,ADXL345_REG_POWER_CTL);
 83e:	1c20      	adds	r0, r4, #0
 840:	212d      	movs	r1, #45	; 0x2d
 842:	4d30      	ldr	r5, [pc, #192]	; (904 <initAccelSensor+0xe8>)
 844:	47a8      	blx	r5
    byteOut(module,0x00);
 846:	1c20      	adds	r0, r4, #0
 848:	2100      	movs	r1, #0
 84a:	47a8      	blx	r5
    SaLDigitalOut(module->SS,true);
 84c:	78e3      	ldrb	r3, [r4, #3]
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 84e:	09d9      	lsrs	r1, r3, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 850:	2200      	movs	r2, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 852:	2900      	cmp	r1, #0
 854:	d104      	bne.n	860 <initAccelSensor+0x44>
        return &(ports[port_index]->Group[group_index]);
 856:	095a      	lsrs	r2, r3, #5
 858:	01d2      	lsls	r2, r2, #7
 85a:	4929      	ldr	r1, [pc, #164]	; (900 <initAccelSensor+0xe4>)
 85c:	468c      	mov	ip, r1
 85e:	4462      	add	r2, ip

void SaLPinMode(uint8_t pin,uint8_t DIR);

static inline void SaLDigitalOut(uint8_t pin, uint8_t level) {
	volatile PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
 860:	211f      	movs	r1, #31
 862:	400b      	ands	r3, r1
 864:	391e      	subs	r1, #30
 866:	4099      	lsls	r1, r3
	

	if (level) {
		port->OUTSET.reg = pin_mask;
 868:	6191      	str	r1, [r2, #24]

    // setRange(module,ADXL345_RANGE_2_G);

    SaLDigitalOut(module->SS,false);
 86a:	78e3      	ldrb	r3, [r4, #3]
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 86c:	09d9      	lsrs	r1, r3, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 86e:	2200      	movs	r2, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 870:	2900      	cmp	r1, #0
 872:	d104      	bne.n	87e <initAccelSensor+0x62>
        return &(ports[port_index]->Group[group_index]);
 874:	095a      	lsrs	r2, r3, #5
 876:	01d2      	lsls	r2, r2, #7
 878:	4921      	ldr	r1, [pc, #132]	; (900 <initAccelSensor+0xe4>)
 87a:	468c      	mov	ip, r1
 87c:	4462      	add	r2, ip

void SaLPinMode(uint8_t pin,uint8_t DIR);

static inline void SaLDigitalOut(uint8_t pin, uint8_t level) {
	volatile PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
 87e:	211f      	movs	r1, #31
 880:	400b      	ands	r3, r1
 882:	391e      	subs	r1, #30
 884:	4099      	lsls	r1, r3
	

	if (level) {
		port->OUTSET.reg = pin_mask;
		} else {
		port->OUTCLR.reg = pin_mask;
 886:	6151      	str	r1, [r2, #20]
    byteOut(module,ADXL345_REG_DATA_FORMAT);
 888:	1c20      	adds	r0, r4, #0
 88a:	2131      	movs	r1, #49	; 0x31
 88c:	4d1d      	ldr	r5, [pc, #116]	; (904 <initAccelSensor+0xe8>)
 88e:	47a8      	blx	r5
    byteOut(module,0b00 | 0b1000);
 890:	1c20      	adds	r0, r4, #0
 892:	2108      	movs	r1, #8
 894:	47a8      	blx	r5
    SaLDigitalOut(module->SS,true);
 896:	78e3      	ldrb	r3, [r4, #3]
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 898:	09d9      	lsrs	r1, r3, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 89a:	2200      	movs	r2, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 89c:	2900      	cmp	r1, #0
 89e:	d104      	bne.n	8aa <initAccelSensor+0x8e>
        return &(ports[port_index]->Group[group_index]);
 8a0:	095a      	lsrs	r2, r3, #5
 8a2:	01d2      	lsls	r2, r2, #7
 8a4:	4916      	ldr	r1, [pc, #88]	; (900 <initAccelSensor+0xe4>)
 8a6:	468c      	mov	ip, r1
 8a8:	4462      	add	r2, ip

void SaLPinMode(uint8_t pin,uint8_t DIR);

static inline void SaLDigitalOut(uint8_t pin, uint8_t level) {
	volatile PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
 8aa:	211f      	movs	r1, #31
 8ac:	400b      	ands	r3, r1
 8ae:	391e      	subs	r1, #30
 8b0:	4099      	lsls	r1, r3
	

	if (level) {
		port->OUTSET.reg = pin_mask;
 8b2:	6191      	str	r1, [r2, #24]

    SaLDigitalOut(module->SS,false);
 8b4:	78e3      	ldrb	r3, [r4, #3]
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 8b6:	09d9      	lsrs	r1, r3, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 8b8:	2200      	movs	r2, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 8ba:	2900      	cmp	r1, #0
 8bc:	d104      	bne.n	8c8 <initAccelSensor+0xac>
        return &(ports[port_index]->Group[group_index]);
 8be:	095a      	lsrs	r2, r3, #5
 8c0:	01d2      	lsls	r2, r2, #7
 8c2:	490f      	ldr	r1, [pc, #60]	; (900 <initAccelSensor+0xe4>)
 8c4:	468c      	mov	ip, r1
 8c6:	4462      	add	r2, ip

void SaLPinMode(uint8_t pin,uint8_t DIR);

static inline void SaLDigitalOut(uint8_t pin, uint8_t level) {
	volatile PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
 8c8:	211f      	movs	r1, #31
 8ca:	400b      	ands	r3, r1
 8cc:	391e      	subs	r1, #30
 8ce:	4099      	lsls	r1, r3
	

	if (level) {
		port->OUTSET.reg = pin_mask;
		} else {
		port->OUTCLR.reg = pin_mask;
 8d0:	6151      	str	r1, [r2, #20]
    byteOut(module,ADXL345_REG_POWER_CTL);
 8d2:	1c20      	adds	r0, r4, #0
 8d4:	212d      	movs	r1, #45	; 0x2d
 8d6:	4d0b      	ldr	r5, [pc, #44]	; (904 <initAccelSensor+0xe8>)
 8d8:	47a8      	blx	r5
    byteOut(module,0x08);
 8da:	1c20      	adds	r0, r4, #0
 8dc:	2108      	movs	r1, #8
 8de:	47a8      	blx	r5
    SaLDigitalOut(module->SS,true);
 8e0:	78e3      	ldrb	r3, [r4, #3]
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 8e2:	09d9      	lsrs	r1, r3, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 8e4:	2200      	movs	r2, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 8e6:	2900      	cmp	r1, #0
 8e8:	d104      	bne.n	8f4 <initAccelSensor+0xd8>
        return &(ports[port_index]->Group[group_index]);
 8ea:	095a      	lsrs	r2, r3, #5
 8ec:	01d2      	lsls	r2, r2, #7
 8ee:	4904      	ldr	r1, [pc, #16]	; (900 <initAccelSensor+0xe4>)
 8f0:	468c      	mov	ip, r1
 8f2:	4462      	add	r2, ip

void SaLPinMode(uint8_t pin,uint8_t DIR);

static inline void SaLDigitalOut(uint8_t pin, uint8_t level) {
	volatile PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
 8f4:	211f      	movs	r1, #31
 8f6:	400b      	ands	r3, r1
 8f8:	391e      	subs	r1, #30
 8fa:	4099      	lsls	r1, r3
	

	if (level) {
		port->OUTSET.reg = pin_mask;
 8fc:	6191      	str	r1, [r2, #24]
    /*=========================================================================*/
}
 8fe:	bd38      	pop	{r3, r4, r5, pc}
 900:	41004400 	.word	0x41004400
 904:	00000271 	.word	0x00000271

00000908 <initBaroSensor>:

void initBaroSensor(struct spiModule *const module ) {
 908:	b510      	push	{r4, lr}
 90a:	1c04      	adds	r4, r0, #0
    /*=========================================================================
    			baro init stuff
    -----------------------------------------------------------------------*/
    SaLDigitalOut(module->SS,false);
 90c:	78c3      	ldrb	r3, [r0, #3]
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 90e:	09d9      	lsrs	r1, r3, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 910:	2200      	movs	r2, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 912:	2900      	cmp	r1, #0
 914:	d104      	bne.n	920 <initBaroSensor+0x18>
        return &(ports[port_index]->Group[group_index]);
 916:	095a      	lsrs	r2, r3, #5
 918:	01d2      	lsls	r2, r2, #7
 91a:	4911      	ldr	r1, [pc, #68]	; (960 <initBaroSensor+0x58>)
 91c:	468c      	mov	ip, r1
 91e:	4462      	add	r2, ip

void SaLPinMode(uint8_t pin,uint8_t DIR);

static inline void SaLDigitalOut(uint8_t pin, uint8_t level) {
	volatile PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
 920:	211f      	movs	r1, #31
 922:	400b      	ands	r3, r1
 924:	391e      	subs	r1, #30
 926:	4099      	lsls	r1, r3
	

	if (level) {
		port->OUTSET.reg = pin_mask;
		} else {
		port->OUTCLR.reg = pin_mask;
 928:	6151      	str	r1, [r2, #20]
    byteOut(module,cmdReset_);
 92a:	1c20      	adds	r0, r4, #0
 92c:	211e      	movs	r1, #30
 92e:	4b0d      	ldr	r3, [pc, #52]	; (964 <initBaroSensor+0x5c>)
 930:	4798      	blx	r3
    SaLDigitalOut(module->SS,true);
 932:	78e3      	ldrb	r3, [r4, #3]
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 934:	09d9      	lsrs	r1, r3, #7
        return &(ports[port_index]->Group[group_index]);
    } else {
        return NULL;
 936:	2200      	movs	r2, #0
    uint8_t port_index  = (gpio_pin / 128);
    uint8_t group_index = (gpio_pin / 32);
    /* Array of available ports */
    Port *const ports[PORT_INST_NUM] = PORT_INSTS;

    if (port_index < PORT_INST_NUM) {
 938:	2900      	cmp	r1, #0
 93a:	d104      	bne.n	946 <initBaroSensor+0x3e>
        return &(ports[port_index]->Group[group_index]);
 93c:	095a      	lsrs	r2, r3, #5
 93e:	01d2      	lsls	r2, r2, #7
 940:	4907      	ldr	r1, [pc, #28]	; (960 <initBaroSensor+0x58>)
 942:	468c      	mov	ip, r1
 944:	4462      	add	r2, ip

void SaLPinMode(uint8_t pin,uint8_t DIR);

static inline void SaLDigitalOut(uint8_t pin, uint8_t level) {
	volatile PortGroup *const port = SaLGetPort(pin);
	uint32_t pin_mask = (1UL << (pin % 32));
 946:	211f      	movs	r1, #31
 948:	400b      	ands	r3, r1
 94a:	391e      	subs	r1, #30
 94c:	4099      	lsls	r1, r3
	

	if (level) {
		port->OUTSET.reg = pin_mask;
 94e:	6191      	str	r1, [r2, #24]
    delay_us(30);
 950:	201e      	movs	r0, #30
 952:	4b05      	ldr	r3, [pc, #20]	; (968 <initBaroSensor+0x60>)
 954:	4798      	blx	r3
    read_coeff(module);
 956:	1c20      	adds	r0, r4, #0
 958:	4b04      	ldr	r3, [pc, #16]	; (96c <initBaroSensor+0x64>)
 95a:	4798      	blx	r3
    /*=========================================================================*/
}
 95c:	bd10      	pop	{r4, pc}
 95e:	46c0      	nop			; (mov r8, r8)
 960:	41004400 	.word	0x41004400
 964:	00000271 	.word	0x00000271
 968:	0000050d 	.word	0x0000050d
 96c:	000001d5 	.word	0x000001d5

00000970 <main>:

}

volatile uint32_t counter = 0;

int main(void) {
 970:	b5f0      	push	{r4, r5, r6, r7, lr}
 972:	464f      	mov	r7, r9
 974:	4646      	mov	r6, r8
 976:	b4c0      	push	{r6, r7}
 978:	b089      	sub	sp, #36	; 0x24
    /* Initialize the SAM system */
    SystemInit();
 97a:	4b2d      	ldr	r3, [pc, #180]	; (a30 <main+0xc0>)
 97c:	4798      	blx	r3
    ClockInit();
 97e:	4b2d      	ldr	r3, [pc, #180]	; (a34 <main+0xc4>)
 980:	4798      	blx	r3
    SaLDelayInit();
 982:	4b2d      	ldr	r3, [pc, #180]	; (a38 <main+0xc8>)
 984:	4798      	blx	r3
    PinConfig();
 986:	4b2d      	ldr	r3, [pc, #180]	; (a3c <main+0xcc>)
 988:	4798      	blx	r3
    struct spiModule baroModule =baroModuleSetup();
 98a:	a806      	add	r0, sp, #24
 98c:	4b2c      	ldr	r3, [pc, #176]	; (a40 <main+0xd0>)
 98e:	4798      	blx	r3
    struct spiModule accelModule =accelModuleSetup();
 990:	a804      	add	r0, sp, #16
 992:	4b2c      	ldr	r3, [pc, #176]	; (a44 <main+0xd4>)
 994:	4798      	blx	r3
    struct USARTModule gpsModule =GPSmoduleSetup();
 996:	a802      	add	r0, sp, #8
 998:	4b2b      	ldr	r3, [pc, #172]	; (a48 <main+0xd8>)
 99a:	4798      	blx	r3

    initAccelSensor(&accelModule);
 99c:	a804      	add	r0, sp, #16
 99e:	4b2b      	ldr	r3, [pc, #172]	; (a4c <main+0xdc>)
 9a0:	4798      	blx	r3
    initBaroSensor(&baroModule);
 9a2:	a806      	add	r0, sp, #24
 9a4:	4b2a      	ldr	r3, [pc, #168]	; (a50 <main+0xe0>)
 9a6:	4798      	blx	r3
	initGPS(&gpsModule);



    volatile int16_t accelX = 0;
 9a8:	2300      	movs	r3, #0
 9aa:	466a      	mov	r2, sp
 9ac:	80d3      	strh	r3, [r2, #6]
    volatile int16_t accelY = 0;
 9ae:	aa01      	add	r2, sp, #4
 9b0:	8013      	strh	r3, [r2, #0]
    volatile int16_t accelZ = 0;
 9b2:	466a      	mov	r2, sp
 9b4:	8053      	strh	r3, [r2, #2]

    SaLPlayTone(900);
 9b6:	20e1      	movs	r0, #225	; 0xe1
 9b8:	0080      	lsls	r0, r0, #2
 9ba:	4c26      	ldr	r4, [pc, #152]	; (a54 <main+0xe4>)
 9bc:	47a0      	blx	r4
    SaLPlayTone(800);
 9be:	20c8      	movs	r0, #200	; 0xc8
 9c0:	0080      	lsls	r0, r0, #2
 9c2:	47a0      	blx	r4
    SaLPlayTone(700);
 9c4:	20af      	movs	r0, #175	; 0xaf
 9c6:	0080      	lsls	r0, r0, #2
 9c8:	47a0      	blx	r4
    SaLPlayTone(600);
 9ca:	2096      	movs	r0, #150	; 0x96
 9cc:	0080      	lsls	r0, r0, #2
 9ce:	47a0      	blx	r4
    SaLPlayTone(500);
 9d0:	20fa      	movs	r0, #250	; 0xfa
 9d2:	0040      	lsls	r0, r0, #1
 9d4:	47a0      	blx	r4

    uint32_t index = 0;
 9d6:	2400      	movs	r4, #0
    while (1) {
        delay_us(100);
 9d8:	4b1f      	ldr	r3, [pc, #124]	; (a58 <main+0xe8>)
 9da:	4699      	mov	r9, r3
        counter++;
 9dc:	4f1f      	ldr	r7, [pc, #124]	; (a5c <main+0xec>)
        getevents(&accelModule);
 9de:	4b20      	ldr	r3, [pc, #128]	; (a60 <main+0xf0>)
 9e0:	4698      	mov	r8, r3
    SaLPlayTone(600);
    SaLPlayTone(500);

    uint32_t index = 0;
    while (1) {
        delay_us(100);
 9e2:	2064      	movs	r0, #100	; 0x64
 9e4:	47c8      	blx	r9
        counter++;
 9e6:	683b      	ldr	r3, [r7, #0]
 9e8:	3301      	adds	r3, #1
 9ea:	603b      	str	r3, [r7, #0]
        getevents(&accelModule);
 9ec:	a804      	add	r0, sp, #16
 9ee:	47c0      	blx	r8
        accelX = currentX();
 9f0:	4b1c      	ldr	r3, [pc, #112]	; (a64 <main+0xf4>)
 9f2:	4798      	blx	r3
 9f4:	466b      	mov	r3, sp
 9f6:	1d9e      	adds	r6, r3, #6
 9f8:	80d8      	strh	r0, [r3, #6]
        accelY = currentY();
 9fa:	4b1b      	ldr	r3, [pc, #108]	; (a68 <main+0xf8>)
 9fc:	4798      	blx	r3
 9fe:	ad01      	add	r5, sp, #4
 a00:	8028      	strh	r0, [r5, #0]
        accelZ = currentZ();
 a02:	4b1a      	ldr	r3, [pc, #104]	; (a6c <main+0xfc>)
 a04:	4798      	blx	r3
 a06:	466b      	mov	r3, sp
 a08:	1c9a      	adds	r2, r3, #2
 a0a:	8058      	strh	r0, [r3, #2]

        accelDataX[index] = accelX;
 a0c:	8830      	ldrh	r0, [r6, #0]
 a0e:	0063      	lsls	r3, r4, #1
 a10:	4917      	ldr	r1, [pc, #92]	; (a70 <main+0x100>)
 a12:	52c8      	strh	r0, [r1, r3]
        accelDataY[index] = accelY;
 a14:	8828      	ldrh	r0, [r5, #0]
 a16:	4917      	ldr	r1, [pc, #92]	; (a74 <main+0x104>)
 a18:	52c8      	strh	r0, [r1, r3]
        accelDataZ[index] = accelZ;
 a1a:	8811      	ldrh	r1, [r2, #0]
 a1c:	4a16      	ldr	r2, [pc, #88]	; (a78 <main+0x108>)
 a1e:	52d1      	strh	r1, [r2, r3]
        index++;
 a20:	3401      	adds	r4, #1
        if (index == 100) {
            index = 0;
 a22:	1c23      	adds	r3, r4, #0
 a24:	3b64      	subs	r3, #100	; 0x64
 a26:	1e5a      	subs	r2, r3, #1
 a28:	4193      	sbcs	r3, r2
 a2a:	425b      	negs	r3, r3
 a2c:	401c      	ands	r4, r3
 a2e:	e7d8      	b.n	9e2 <main+0x72>
 a30:	00000691 	.word	0x00000691
 a34:	000006a1 	.word	0x000006a1
 a38:	000004ed 	.word	0x000004ed
 a3c:	00000729 	.word	0x00000729
 a40:	0000075d 	.word	0x0000075d
 a44:	000007a5 	.word	0x000007a5
 a48:	000007ed 	.word	0x000007ed
 a4c:	0000081d 	.word	0x0000081d
 a50:	00000909 	.word	0x00000909
 a54:	0000049d 	.word	0x0000049d
 a58:	0000050d 	.word	0x0000050d
 a5c:	20000454 	.word	0x20000454
 a60:	00000115 	.word	0x00000115
 a64:	000001b1 	.word	0x000001b1
 a68:	000001bd 	.word	0x000001bd
 a6c:	000001c9 	.word	0x000001c9
 a70:	200005fc 	.word	0x200005fc
 a74:	2000046c 	.word	0x2000046c
 a78:	20000534 	.word	0x20000534

00000a7c <__libc_init_array>:
 a7c:	b570      	push	{r4, r5, r6, lr}
 a7e:	4e0d      	ldr	r6, [pc, #52]	; (ab4 <__libc_init_array+0x38>)
 a80:	4d0d      	ldr	r5, [pc, #52]	; (ab8 <__libc_init_array+0x3c>)
 a82:	2400      	movs	r4, #0
 a84:	1bad      	subs	r5, r5, r6
 a86:	10ad      	asrs	r5, r5, #2
 a88:	d005      	beq.n	a96 <__libc_init_array+0x1a>
 a8a:	00a3      	lsls	r3, r4, #2
 a8c:	58f3      	ldr	r3, [r6, r3]
 a8e:	3401      	adds	r4, #1
 a90:	4798      	blx	r3
 a92:	42a5      	cmp	r5, r4
 a94:	d1f9      	bne.n	a8a <__libc_init_array+0xe>
 a96:	f000 f8b1 	bl	bfc <_init>
 a9a:	4e08      	ldr	r6, [pc, #32]	; (abc <__libc_init_array+0x40>)
 a9c:	4d08      	ldr	r5, [pc, #32]	; (ac0 <__libc_init_array+0x44>)
 a9e:	2400      	movs	r4, #0
 aa0:	1bad      	subs	r5, r5, r6
 aa2:	10ad      	asrs	r5, r5, #2
 aa4:	d005      	beq.n	ab2 <__libc_init_array+0x36>
 aa6:	00a3      	lsls	r3, r4, #2
 aa8:	58f3      	ldr	r3, [r6, r3]
 aaa:	3401      	adds	r4, #1
 aac:	4798      	blx	r3
 aae:	42a5      	cmp	r5, r4
 ab0:	d1f9      	bne.n	aa6 <__libc_init_array+0x2a>
 ab2:	bd70      	pop	{r4, r5, r6, pc}
 ab4:	00000c08 	.word	0x00000c08
 ab8:	00000c08 	.word	0x00000c08
 abc:	00000c08 	.word	0x00000c08
 ac0:	00000c10 	.word	0x00000c10

00000ac4 <register_fini>:
 ac4:	b508      	push	{r3, lr}
 ac6:	4b03      	ldr	r3, [pc, #12]	; (ad4 <register_fini+0x10>)
 ac8:	2b00      	cmp	r3, #0
 aca:	d002      	beq.n	ad2 <register_fini+0xe>
 acc:	4802      	ldr	r0, [pc, #8]	; (ad8 <register_fini+0x14>)
 ace:	f000 f805 	bl	adc <atexit>
 ad2:	bd08      	pop	{r3, pc}
 ad4:	00000000 	.word	0x00000000
 ad8:	00000aed 	.word	0x00000aed

00000adc <atexit>:
 adc:	b508      	push	{r3, lr}
 ade:	1c01      	adds	r1, r0, #0
 ae0:	2200      	movs	r2, #0
 ae2:	2000      	movs	r0, #0
 ae4:	2300      	movs	r3, #0
 ae6:	f000 f81b 	bl	b20 <__register_exitproc>
 aea:	bd08      	pop	{r3, pc}

00000aec <__libc_fini_array>:
 aec:	b538      	push	{r3, r4, r5, lr}
 aee:	4b09      	ldr	r3, [pc, #36]	; (b14 <__libc_fini_array+0x28>)
 af0:	4c09      	ldr	r4, [pc, #36]	; (b18 <__libc_fini_array+0x2c>)
 af2:	1ae4      	subs	r4, r4, r3
 af4:	10a4      	asrs	r4, r4, #2
 af6:	d009      	beq.n	b0c <__libc_fini_array+0x20>
 af8:	4a08      	ldr	r2, [pc, #32]	; (b1c <__libc_fini_array+0x30>)
 afa:	18a5      	adds	r5, r4, r2
 afc:	00ad      	lsls	r5, r5, #2
 afe:	18ed      	adds	r5, r5, r3
 b00:	682b      	ldr	r3, [r5, #0]
 b02:	3c01      	subs	r4, #1
 b04:	4798      	blx	r3
 b06:	3d04      	subs	r5, #4
 b08:	2c00      	cmp	r4, #0
 b0a:	d1f9      	bne.n	b00 <__libc_fini_array+0x14>
 b0c:	f000 f880 	bl	c10 <_fini>
 b10:	bd38      	pop	{r3, r4, r5, pc}
 b12:	46c0      	nop			; (mov r8, r8)
 b14:	00000c1c 	.word	0x00000c1c
 b18:	00000c20 	.word	0x00000c20
 b1c:	3fffffff 	.word	0x3fffffff

00000b20 <__register_exitproc>:
 b20:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 b22:	4644      	mov	r4, r8
 b24:	465f      	mov	r7, fp
 b26:	4656      	mov	r6, sl
 b28:	464d      	mov	r5, r9
 b2a:	469b      	mov	fp, r3
 b2c:	4b2f      	ldr	r3, [pc, #188]	; (bec <__register_exitproc+0xcc>)
 b2e:	b4f0      	push	{r4, r5, r6, r7}
 b30:	681c      	ldr	r4, [r3, #0]
 b32:	23a4      	movs	r3, #164	; 0xa4
 b34:	005b      	lsls	r3, r3, #1
 b36:	1c05      	adds	r5, r0, #0
 b38:	58e0      	ldr	r0, [r4, r3]
 b3a:	1c0e      	adds	r6, r1, #0
 b3c:	4690      	mov	r8, r2
 b3e:	2800      	cmp	r0, #0
 b40:	d04b      	beq.n	bda <__register_exitproc+0xba>
 b42:	6843      	ldr	r3, [r0, #4]
 b44:	2b1f      	cmp	r3, #31
 b46:	dc0d      	bgt.n	b64 <__register_exitproc+0x44>
 b48:	1c5c      	adds	r4, r3, #1
 b4a:	2d00      	cmp	r5, #0
 b4c:	d121      	bne.n	b92 <__register_exitproc+0x72>
 b4e:	3302      	adds	r3, #2
 b50:	009b      	lsls	r3, r3, #2
 b52:	6044      	str	r4, [r0, #4]
 b54:	501e      	str	r6, [r3, r0]
 b56:	2000      	movs	r0, #0
 b58:	bc3c      	pop	{r2, r3, r4, r5}
 b5a:	4690      	mov	r8, r2
 b5c:	4699      	mov	r9, r3
 b5e:	46a2      	mov	sl, r4
 b60:	46ab      	mov	fp, r5
 b62:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 b64:	4b22      	ldr	r3, [pc, #136]	; (bf0 <__register_exitproc+0xd0>)
 b66:	2b00      	cmp	r3, #0
 b68:	d03c      	beq.n	be4 <__register_exitproc+0xc4>
 b6a:	20c8      	movs	r0, #200	; 0xc8
 b6c:	0040      	lsls	r0, r0, #1
 b6e:	e000      	b.n	b72 <__register_exitproc+0x52>
 b70:	bf00      	nop
 b72:	2800      	cmp	r0, #0
 b74:	d036      	beq.n	be4 <__register_exitproc+0xc4>
 b76:	22a4      	movs	r2, #164	; 0xa4
 b78:	2300      	movs	r3, #0
 b7a:	0052      	lsls	r2, r2, #1
 b7c:	58a1      	ldr	r1, [r4, r2]
 b7e:	6043      	str	r3, [r0, #4]
 b80:	6001      	str	r1, [r0, #0]
 b82:	50a0      	str	r0, [r4, r2]
 b84:	3240      	adds	r2, #64	; 0x40
 b86:	5083      	str	r3, [r0, r2]
 b88:	3204      	adds	r2, #4
 b8a:	5083      	str	r3, [r0, r2]
 b8c:	2401      	movs	r4, #1
 b8e:	2d00      	cmp	r5, #0
 b90:	d0dd      	beq.n	b4e <__register_exitproc+0x2e>
 b92:	009a      	lsls	r2, r3, #2
 b94:	4691      	mov	r9, r2
 b96:	4481      	add	r9, r0
 b98:	4642      	mov	r2, r8
 b9a:	2188      	movs	r1, #136	; 0x88
 b9c:	464f      	mov	r7, r9
 b9e:	507a      	str	r2, [r7, r1]
 ba0:	22c4      	movs	r2, #196	; 0xc4
 ba2:	0052      	lsls	r2, r2, #1
 ba4:	4690      	mov	r8, r2
 ba6:	4480      	add	r8, r0
 ba8:	4642      	mov	r2, r8
 baa:	3987      	subs	r1, #135	; 0x87
 bac:	4099      	lsls	r1, r3
 bae:	6812      	ldr	r2, [r2, #0]
 bb0:	468a      	mov	sl, r1
 bb2:	430a      	orrs	r2, r1
 bb4:	4694      	mov	ip, r2
 bb6:	4642      	mov	r2, r8
 bb8:	4661      	mov	r1, ip
 bba:	6011      	str	r1, [r2, #0]
 bbc:	2284      	movs	r2, #132	; 0x84
 bbe:	4649      	mov	r1, r9
 bc0:	465f      	mov	r7, fp
 bc2:	0052      	lsls	r2, r2, #1
 bc4:	508f      	str	r7, [r1, r2]
 bc6:	2d02      	cmp	r5, #2
 bc8:	d1c1      	bne.n	b4e <__register_exitproc+0x2e>
 bca:	1c02      	adds	r2, r0, #0
 bcc:	4655      	mov	r5, sl
 bce:	328d      	adds	r2, #141	; 0x8d
 bd0:	32ff      	adds	r2, #255	; 0xff
 bd2:	6811      	ldr	r1, [r2, #0]
 bd4:	430d      	orrs	r5, r1
 bd6:	6015      	str	r5, [r2, #0]
 bd8:	e7b9      	b.n	b4e <__register_exitproc+0x2e>
 bda:	1c20      	adds	r0, r4, #0
 bdc:	304d      	adds	r0, #77	; 0x4d
 bde:	30ff      	adds	r0, #255	; 0xff
 be0:	50e0      	str	r0, [r4, r3]
 be2:	e7ae      	b.n	b42 <__register_exitproc+0x22>
 be4:	2001      	movs	r0, #1
 be6:	4240      	negs	r0, r0
 be8:	e7b6      	b.n	b58 <__register_exitproc+0x38>
 bea:	46c0      	nop			; (mov r8, r8)
 bec:	00000bf8 	.word	0x00000bf8
 bf0:	00000000 	.word	0x00000000
 bf4:	00000043 	.word	0x00000043

00000bf8 <_global_impure_ptr>:
 bf8:	20000010                                ... 

00000bfc <_init>:
 bfc:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 bfe:	46c0      	nop			; (mov r8, r8)
 c00:	bcf8      	pop	{r3, r4, r5, r6, r7}
 c02:	bc08      	pop	{r3}
 c04:	469e      	mov	lr, r3
 c06:	4770      	bx	lr

00000c08 <__init_array_start>:
 c08:	00000ac5 	.word	0x00000ac5

00000c0c <__frame_dummy_init_array_entry>:
 c0c:	000000dd                                ....

00000c10 <_fini>:
 c10:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 c12:	46c0      	nop			; (mov r8, r8)
 c14:	bcf8      	pop	{r3, r4, r5, r6, r7}
 c16:	bc08      	pop	{r3}
 c18:	469e      	mov	lr, r3
 c1a:	4770      	bx	lr

00000c1c <__fini_array_start>:
 c1c:	000000b5 	.word	0x000000b5
